class AnimationManager{#animations;constructor(){this.#animations=new Set;this.update()}addAnimation(animation){if(!(animation instanceof Animation)){throw new Error("Invalid argument: animation should be an instance of Animation.")}this.#animations.add(animation)}removeAnimation(animation){if(!(animation instanceof Animation)){throw new Error("Invalid argument: animation should be an instance of Animation.")}this.#animations["delete"](animation)}update(){const now=performance.now();for(const animation of this.#animations){if(animation.isPlaying){animation.update(now)}}requestAnimationFrame(()=>this.update())}get animations(){return this.#animations}}class AnimationFrame{#image;#srcX;#srcY;#width;#height;constructor(image,srcX,srcY,width,height){if(!(image instanceof Image)){throw new Error("Invalid argument: image should be an instance of Image.")}if(typeof srcX!=="number"||typeof srcY!=="number"||typeof width!=="number"||typeof height!=="number"){throw new Error("Invalid arguments: srcX, srcY, width, and height should be numbers.")}if(srcX<0||srcY<0||width<=0||height<=0){throw new Error("Invalid arguments: srcX, srcY should be greater than or equal to 0, width, and height should be greater than 0.")}if(srcX+width>image.width||srcY+height>image.height){throw new Error("Invalid arguments: The source rectangle should be within the bounds of the image.")}this.#image=image;this.#srcX=srcX;this.#srcY=srcY;this.#width=width;this.#height=height}get image(){return this.#image}get srcX(){return this.#srcX}get srcY(){return this.#srcY}get width(){return this.#width}get height(){return this.#height}}class Animation{#image;#frameCount;#frameDuration;#frameWidth;#frameHeight;#rows;#columns;#position;#sizeFactor;#currentFrame;#elapsedTime;#isPlaying;#lastUpdateTime;#once;constructor(image,frameCount,frameDuration,frameWidth,frameHeight,columns=frameCount,rows=1,position=new Vector(0,0),sizeFactor=1){if(!(image instanceof Image)){throw new Error("Invalid argument: image should be an instance of Image.")}if(typeof frameCount!=="number"||frameCount<=0){throw new Error("Invalid argument: frameCount should be a positive number.")}if(typeof frameDuration!=="number"||frameDuration<=0){throw new Error("Invalid argument: frameDuration should be a positive number.")}if(typeof frameWidth!=="number"||frameWidth<=0){throw new Error("Invalid argument: frameWidth should be a positive number.")}if(typeof frameHeight!=="number"||frameHeight<=0){throw new Error("Invalid argument: frameHeight should be a positive number.")}if(typeof rows!=="number"||rows<=0){throw new Error("Invalid argument: rows should be a positive number.")}if(typeof columns!=="number"||columns<=0){throw new Error("Invalid argument: columns should be a positive number.")}if(!(position instanceof Vector)){throw new Error("Invalid argument: position must be an instance of Vector.")}if(typeof sizeFactor!=="number"||sizeFactor<=0){throw new Error("Invalid argument: sizeFactor should be a positive number.")}this.#image=image;this.#frameCount=frameCount;this.#frameDuration=frameDuration;this.#frameWidth=frameWidth;this.#frameHeight=frameHeight;this.#rows=rows;this.#columns=columns;this.#position=position;this.#sizeFactor=sizeFactor;this.#currentFrame=0;this.#elapsedTime=0;this.#isPlaying=false;this.#lastUpdateTime=0;this.#once=false}play(){this.#isPlaying=true;this.#lastUpdateTime=performance.now();this.#once=false}playOnce(){this.#isPlaying=true;this.#lastUpdateTime=performance.now();this.#once=true}pause(){this.#isPlaying=false}stop(){this.#isPlaying=false;this.#currentFrame=0;this.#elapsedTime=0}update(now){const elapsed=now-this.#lastUpdateTime;if(elapsed>this.#frameDuration){this.#currentFrame++;if(this.#once&&this.#currentFrame>=this.#frameCount){this.stop()}else{this.#currentFrame%=this.#frameCount}this.#lastUpdateTime=now}}getCurrentFrame(){const rowIndex=Math.floor(this.#currentFrame/this.#columns);const colIndex=this.#currentFrame%this.#columns;const srcX=colIndex*this.#frameWidth;const srcY=rowIndex*this.#frameHeight;return new AnimationFrame(this.#image,srcX,srcY,this.#frameWidth,this.#frameHeight)}get image(){return this.#image}get frameCount(){return this.#frameCount}get frameDuration(){return this.#frameDuration}set frameDuration(value){if(typeof value!=="number"||value<=0){throw new Error("Invalid argument: frameDuration should be a positive number.")}this.#frameDuration=value}get frameWidth(){return this.#frameWidth}get frameHeight(){return this.#frameHeight}get currentFrame(){return this.#currentFrame}get elapsedTime(){return this.#elapsedTime}get isPlaying(){return this.#isPlaying}get position(){return this.#position}get sizeFactor(){return this.#sizeFactor}set position(position){if(!(position instanceof Vector)){throw new Error("Invalid argument: position must be an instance of Vector.")}this.#position=position}set sizeFactor(sizeFactor){if(typeof sizeFactor!=="number"||sizeFactor<=0){throw new Error("Invalid argument: sizeFactor should be a positive number.")}this.#sizeFactor=sizeFactor}}class AssetLoader{#totalAssets;#loadedAssets;constructor(){this.#totalAssets=0;this.#loadedAssets=0}loadAssets(eventName,assets=[]){if(typeof eventName!=="string"){throw new Error("Invalid argument: eventName should be a string.")}if(!Array.isArray(assets)){throw new Error("Invalid argument: assets should be an array.")}this.totalAssets=assets.reduce((acc,asset)=>acc+asset.paths.length,0);this.loadedAssets=0;const updateProgress=()=>{this.loadedAssets++};const promises=assets.map((asset,index)=>{if(typeof asset!=="object"||asset===null){throw new Error(`Invalid argument: assets[${index}] should be an object.`)}const{type,paths,name}=asset;if(type!=="image"&&type!=="audio"&&type!=="texture"){throw new Error(`Invalid argument: assets[${index}].type should be either 'image', 'audio' or 'texture'.`)}if(typeof name!=="string"){throw new Error(`Invalid argument: assets[${index}].name should be a string.`)}if(!Array.isArray(paths)||!paths.every(path=>typeof path==="string")){throw new Error(`Invalid argument: assets[${index}].paths should be an array of strings.`)}let loadPromise;if(type==="audio"){loadPromise=this.#loadAudios(paths)}else if(type==="texture"){loadPromise=this.#loadTextures(paths)}else{loadPromise=this.#loadImages(paths)}return loadPromise.then(loadedAsset=>{paths.forEach(()=>updateProgress());return loadedAsset})});Promise.all(promises).then(loadedAssets=>{const eventDetail={};assets.forEach((asset,index)=>{eventDetail[asset.name]=loadedAssets[index]});const event=new CustomEvent(eventName,{detail:eventDetail});window.dispatchEvent(event)})["catch"](error=>{console.error("Failed to load assets: ",error)})}#loadImages(paths){return Promise.all(paths.map(path=>this.#loadImage(path)))}#loadTextures(paths){return Promise.all(paths.map(path=>this.#loadTexture(path)))}#loadAudios(paths){return Promise.all(paths.map(path=>this.#loadAudio(path)))}#loadImage(path){return new Promise((resolve,reject)=>{const img=new Image;img.onload=()=>resolve(img);img.onerror=reject;img.src=path})}#loadTexture(path){return new Promise((resolve,reject)=>{const img=new Image;img.onload=()=>resolve(this.#imageToTexture(img));img.onerror=reject;img.crossOrigin="";img.src=path})}#loadAudio(path){return new Promise((resolve,reject)=>{const audio=new Audio;audio.onloadeddata=()=>resolve(audio);audio.onerror=reject;audio.src=path})}#imageToTexture(image){const canvas=document.createElement("canvas");canvas.width=image.width;canvas.height=image.height;const ctx=canvas.getContext("2d");ctx.drawImage(image,0,0,image.width,image.height);const imageData=ctx.getImageData(0,0,image.width,image.height);return{data:imageData.data,width:image.width,height:image.height}}getProgress(){if(this.totalAssets===0)return 1;return this.loadedAssets/this.totalAssets}}class Camera{#gameWidth;#gameHeight;#canvasWidth;#canvasHeight;#aspectRatio;#boundResizeCanvas;#fullscreenHandler;#fpsUpdateRate;#canvas;#ctx;#renderer;#renderLoop;#canvasName;#smooth;#deltaTime=0;#currentTime=0;#lastTime=0;#startTime;#fps=0;#displayFPS=false;#frames=0;#lastFPSUpdate=0;#isPostProcessingOverridden=false;constructor(gameWidth,gameHeight,canvasWidth,canvasHeight,canvasName,smooth=false){if(typeof gameWidth!=="number"||gameWidth<=0){throw new Error("Invalid gameWidth: Expected a positive number.")}if(typeof gameHeight!=="number"||gameHeight<=0){throw new Error("Invalid gameHeight: Expected a positive number.")}if(typeof canvasWidth!=="number"||canvasWidth<=0){throw new Error("Invalid canvasWidth: Expected a positive number.")}if(typeof canvasHeight!=="number"||canvasHeight<=0){throw new Error("Invalid canvasHeight: Expected a positive number.")}if(typeof canvasName!=="string"||canvasName.trim()===""){throw new Error("Invalid canvasName: Expected a non-empty string.")}if(typeof smooth!=="boolean"){throw new Error("Invalid smooth value: Expected a boolean.")}this.#gameWidth=gameWidth;this.#gameHeight=gameHeight;this.#canvasWidth=canvasWidth;this.#canvasHeight=canvasHeight;this.#canvasName=canvasName;this.#smooth=smooth;this.#aspectRatio=gameWidth/gameHeight;this.#fpsUpdateRate=300;this.#boundResizeCanvas=this.#resizeCanvas.bind(this);this.#renderer=this.#render.bind(this);this.#fullscreenHandler=this.#handleFullscreen.bind(this)}#initializeCanvas(canvasName){this.#canvas=document.getElementById(canvasName);this.#ctx=this.#canvas.getContext("2d");this.#ctx.canvas.width=this.#gameWidth;this.#ctx.canvas.height=this.#gameHeight;if(!this.#smooth)this.#canvas.style.imageRendering="pixelated";this.#canvas.style.width=`${this.#canvasWidth}px`;this.#canvas.style.height=`${this.#canvasHeight}px`;this.#ctx.imageSmoothingEnabled=false;this.#ctx.mozImageSmoothingEnabled=false;this.#ctx.webkitImageSmoothingEnabled=false;this.#ctx.msImageSmoothingEnabled=false;window.addEventListener("fullscreenchange",this.#fullscreenHandler)}#render(){this.#renderLoop=window.requestAnimationFrame(this.#render.bind(this));this.#lastTime=this.#currentTime;this.#currentTime=performance.now();this.#deltaTime=(this.#currentTime-this.#lastTime)/1e3;this.#ctx.clearRect(0,0,this.#gameWidth,this.#gameHeight);this.update();if(this.postProcessing!==Camera.prototype.postProcessing&&!this.#isPostProcessingOverridden){this.#isPostProcessingOverridden=true;console.log("Post-processing is overridden!")}if(this.#isPostProcessingOverridden){const imageData=this.#ctx.getImageData(0,0,this.#gameWidth,this.#gameHeight);this.postProcessing(imageData);this.#ctx.putImageData(imageData,0,0)}this.ui();if(this.#displayFPS){this.#calculateFPS()}}#calculateFPS(){this.#frames++;if(this.#currentTime>=this.#lastFPSUpdate+this.#fpsUpdateRate){this.#fps=(this.#frames/((this.#currentTime-this.#lastFPSUpdate)/1e3)).toFixed(2);this.#frames=0;this.#lastFPSUpdate=this.#currentTime}const fontSize=Math.max(Math.round((this.#gameWidth+this.#gameHeight)/50),10);this.#ctx.font=`${fontSize}px Arial`;this.#ctx.fillStyle="white";this.#ctx.fillText("FPS: "+Math.round(this.#fps),10,fontSize+10)}init(autoWaitForCanvas=false,maxRetries=10,retryInterval=50){if(typeof autoWaitForCanvas!=="boolean"){throw new TypeError(`Expected 'autoWaitForCanvas' to be a boolean, but received ${typeof autoWaitForCanvas}.`)}if(typeof maxRetries!=="number"||maxRetries<1){throw new TypeError(`Expected 'maxRetries' to be a positive number, but received ${maxRetries}.`)}if(typeof retryInterval!=="number"||retryInterval<0){throw new TypeError(`Expected 'retryInterval' to be a non-negative number, but received ${retryInterval}.`)}const tryInitializeCanvas=()=>{if(document.getElementById(this.#canvasName)){if(this.observer){this.observer.disconnect();this.observer=null}this.#initializeCanvas(this.#canvasName);this.#startTime=performance.now();this.start();this.#renderLoop=window.requestAnimationFrame(this.#renderer)}};tryInitializeCanvas();if(!this.#canvas&&autoWaitForCanvas){let retryCount=0;const waitForBodyAndObserve=()=>{if(document.body){this.observer=new MutationObserver(tryInitializeCanvas);this.observer.observe(document.body,{childList:true,subtree:true})}else if(retryCount<maxRetries){retryCount++;setTimeout(waitForBodyAndObserve,retryInterval)}else{console.warn("Max retries reached while waiting for document.body.")}};waitForBodyAndObserve()}else if(!this.#canvas){throw new Error(`Failed to initialize: Canvas with ID "${this.#canvasName}" is not present in the document. If you expect the canvas to be added later, consider setting 'autoWaitForCanvas' to true.`)}}toggleFPSDisplay(){this.#displayFPS=!this.#displayFPS}lockCursor(){this.#canvas.addEventListener("click",async()=>{await this.#canvas.requestPointerLock({unadjustedMovement:true})})}getDeltaTime(){return Math.min(this.#deltaTime,1)}getTime(){return(this.#currentTime-this.#startTime)/1e3}drawImageData(imageData){if(!(imageData instanceof ImageData)){throw new Error("Invalid argument: imageData should be an instance of ImageData.")}if(imageData.width!==this.#gameWidth||imageData.height!==this.#gameHeight){throw new Error("Mismatched dimensions: The imageData dimensions do not match the canvas dimensions.")}if(imageData.data.length!==this.#gameWidth*this.#gameHeight*4){throw new Error("Invalid imageData data length.")}this.ctx.putImageData(imageData,0,0)}drawImageDataWithMismatch(imageData){if(!(imageData instanceof ImageData)){throw new Error("Invalid argument: imageData should be an instance of ImageData.")}if(imageData.data.length!==imageData.width*imageData.height*4){throw new Error("Invalid imageData data length.")}const tempCanvas=document.createElement("canvas");const tempCtx=tempCanvas.getContext("2d");tempCanvas.width=imageData.width;tempCanvas.height=imageData.height;tempCtx.putImageData(imageData,0,0);this.ctx.drawImage(tempCanvas,0,0,this.#gameWidth,this.#gameHeight)}drawImage(image,position,width,height,angle=0,sourcePosition=new Vector(0,0),srcWidth=image.width,srcHeight=image.height,reflectX=false,reflectY=false){if(!(image instanceof Image)){throw new Error("Invalid argument: image should be an instance of Image.")}if(!(position instanceof Vector)||!(sourcePosition instanceof Vector)){throw new Error("Invalid arguments: Expected Vector objects for position and sourcePosition.")}if(typeof width!=="number"||typeof height!=="number"){throw new Error("Invalid arguments: width and height should be numbers.")}if(typeof angle!=="number"){throw new Error("Invalid argument: angle should be a number.")}if(typeof reflectX!=="boolean"||typeof reflectY!=="boolean"){throw new Error("Invalid arguments: reflectX and reflectY should be booleans.")}this.#ctx.save();this.#ctx.translate(position.x,position.y);this.#ctx.rotate(angle*Math.PI/180);let scaleX=reflectX?-1:1;let scaleY=reflectY?-1:1;this.#ctx.scale(scaleX,scaleY);let drawX=-width/2;let drawY=-height/2;this.#ctx.drawImage(image,sourcePosition.x,sourcePosition.y,srcWidth,srcHeight,drawX,drawY,width,height);this.#ctx.restore()}drawAnimationFrame(frame,position,width,height,angle=0,reflectX=false,reflectY=false){if(!(frame instanceof AnimationFrame)){throw new Error("Invalid argument: frame should be an instance of AnimationFrame.")}if(!(position instanceof Vector)){throw new Error("Invalid position: Expected a Vector object.")}if(typeof width!=="number"||typeof height!=="number"){throw new Error("Invalid arguments: width and height should be numbers.")}if(typeof angle!=="number"){throw new Error("Invalid argument: angle should be a number.")}if(typeof reflectX!=="boolean"||typeof reflectY!=="boolean"){throw new Error("Invalid arguments: reflectX and reflectY should be booleans.")}this.drawImage(frame.image,position,width,height,angle,new Vector(frame.srcX,frame.srcY),frame.width,frame.height,reflectX,reflectY)}drawRect(position,width,height,color=new Color(127,0,0,255),angle=0){if(!(position instanceof Vector)){throw new Error("Invalid position: Expected a Vector object.")}if(typeof width!=="number"||typeof height!=="number"){throw new Error("Invalid arguments: Expected numbers for width and height.")}if(!(color instanceof Color)){throw new Error("Invalid color: Expected a Color object.")}if(typeof angle!=="number"){throw new Error("Invalid angle: Expected a number.")}this.#ctx.save();this.#ctx.translate(position.x,position.y);this.#ctx.rotate(angle*Math.PI/180);this.#ctx.fillStyle=color.getColorAsHex();this.#ctx.fillRect(-width/2,-height/2,width,height);this.#ctx.restore()}drawRectOutline(position,width,height,color=new Color(127,0,0,255),outlineColor=new Color(255,0,0,255),lineWidth=1,angle=0){if(!(position instanceof Vector)){throw new Error("Invalid position: Expected a Vector object.")}if(typeof width!=="number"||typeof height!=="number"){throw new Error("Invalid arguments: width and height should be numbers.")}if(!(color instanceof Color)||!(outlineColor instanceof Color)){throw new Error("Invalid arguments: color and outlineColor should be Color objects.")}if(typeof lineWidth!=="number"){throw new Error("Invalid argument: lineWidth should be a number.")}if(typeof angle!=="number"){throw new Error("Invalid angle: Expected a number.")}this.#ctx.save();this.#ctx.translate(position.x,position.y);this.#ctx.rotate(angle*Math.PI/180);this.#ctx.fillStyle=color.getColorAsHex();this.#ctx.fillRect(-width/2,-height/2,width,height);this.#ctx.lineWidth=lineWidth;this.#ctx.strokeStyle=outlineColor.getColorAsHex();this.#ctx.strokeRect(-width/2,-height/2,width,height);this.#ctx.restore()}drawTriangle(pos1,pos2,pos3,color=new Color(127,0,0,255),angle=0){if(!(pos1 instanceof Vector)||!(pos2 instanceof Vector)||!(pos3 instanceof Vector)){throw new Error("Invalid positions: Expected Vector objects for pos1, pos2, and pos3.")}if(!(color instanceof Color)){throw new Error("Invalid color: Expected a Color object.")}if(typeof angle!=="number"){throw new Error("Invalid angle: Expected a number.")}const centroid=new Vector((pos1.x+pos2.x+pos3.x)/3,(pos1.y+pos2.y+pos3.y)/3);this.#ctx.save();this.#ctx.translate(centroid.x,centroid.y);this.#ctx.rotate(angle*Math.PI/180);this.#ctx.fillStyle=color.getColorAsHex();this.#ctx.beginPath();this.#ctx.moveTo(pos1.x-centroid.x,pos1.y-centroid.y);this.#ctx.lineTo(pos2.x-centroid.x,pos2.y-centroid.y);this.#ctx.lineTo(pos3.x-centroid.x,pos3.y-centroid.y);this.#ctx.closePath();this.#ctx.fill();this.#ctx.restore()}drawTriangleOutline(pos1,pos2,pos3,color=new Color(127,0,0,255),outlineColor=new Color(255,0,0,255),lineWidth=1,angle=0){if(!(pos1 instanceof Vector)||!(pos2 instanceof Vector)||!(pos3 instanceof Vector)){throw new Error("Invalid positions: Expected Vector objects for pos1, pos2, and pos3.")}if(!(color instanceof Color)||!(outlineColor instanceof Color)){throw new Error("Invalid arguments: color and outlineColor should be Color objects.")}if(typeof lineWidth!=="number"){throw new Error("Invalid argument: lineWidth should be a number.")}if(typeof angle!=="number"){throw new Error("Invalid angle: Expected a number.")}const centroid=new Vector((pos1.x+pos2.x+pos3.x)/3,(pos1.y+pos2.y+pos3.y)/3);this.#ctx.save();this.#ctx.translate(centroid.x,centroid.y);this.#ctx.rotate(angle*Math.PI/180);this.#ctx.fillStyle=color.getColorAsHex();this.#ctx.strokeStyle=outlineColor.getColorAsHex();this.#ctx.lineWidth=lineWidth;this.#ctx.beginPath();this.#ctx.moveTo(pos1.x-centroid.x,pos1.y-centroid.y);this.#ctx.lineTo(pos2.x-centroid.x,pos2.y-centroid.y);this.#ctx.lineTo(pos3.x-centroid.x,pos3.y-centroid.y);this.#ctx.closePath();this.#ctx.fill();this.#ctx.stroke();this.#ctx.restore()}drawPolygon(position,outerRadius,corners,color=new Color(127,0,0,255),angle=0){if(!(position instanceof Vector)){throw new Error("Invalid position: Expected a Vector object.")}if(typeof outerRadius!=="number"||outerRadius<=0){throw new Error("Invalid outerRadius: Expected a positive number.")}if(typeof corners!=="number"||corners<3){throw new Error("Invalid number of corners: Minimum is 3.")}if(!(color instanceof Color)){throw new Error("Invalid color: Expected a Color object.")}if(typeof angle!=="number"){throw new Error("Invalid angle: Expected a number.")}const angleIncrement=2*Math.PI/corners;this.#ctx.save();this.#ctx.translate(position.x,position.y);this.#ctx.rotate(angle*Math.PI/180);this.#ctx.fillStyle=color.getColorAsHex();this.#ctx.beginPath();for(let i=0;i<corners;i++){const x=outerRadius*Math.cos(i*angleIncrement);const y=outerRadius*Math.sin(i*angleIncrement);if(i===0){this.#ctx.moveTo(x,y)}else{this.#ctx.lineTo(x,y)}}this.#ctx.closePath();this.#ctx.fill();this.#ctx.restore()}drawPolygonOutline(position,outerRadius,corners,color=new Color(127,0,0,255),outlineColor=new Color(255,0,0,255),lineWidth=1,angle=0){if(!(position instanceof Vector)){throw new Error("Invalid position: Expected a Vector object.")}if(typeof outerRadius!=="number"||outerRadius<=0){throw new Error("Invalid outerRadius: Expected a positive number.")}if(typeof corners!=="number"||corners<3){throw new Error("Invalid number of corners: Minimum is 3.")}if(!(color instanceof Color)||!(outlineColor instanceof Color)){throw new Error("Invalid arguments: color and outlineColor should be Color objects.")}if(typeof lineWidth!=="number"||lineWidth<=0){throw new Error("Invalid lineWidth: Expected a positive number.")}if(typeof angle!=="number"){throw new Error("Invalid angle: Expected a number.")}const angleIncrement=2*Math.PI/corners;this.#ctx.save();this.#ctx.translate(position.x,position.y);this.#ctx.rotate(angle*Math.PI/180);this.#ctx.beginPath();for(let i=0;i<corners;i++){const x=outerRadius*Math.cos(i*angleIncrement);const y=outerRadius*Math.sin(i*angleIncrement);if(i===0){this.#ctx.moveTo(x,y)}else{this.#ctx.lineTo(x,y)}}this.#ctx.closePath();this.#ctx.fillStyle=color.getColorAsHex();this.#ctx.fill();this.#ctx.lineWidth=lineWidth;this.#ctx.strokeStyle=outlineColor.getColorAsHex();this.#ctx.stroke();this.#ctx.restore()}drawEllipse(center,radiusX,radiusY,color=new Color(127,0,0,255),angle=0){if(!(center instanceof Vector)){throw new Error("Invalid center: Expected a Vector object.")}if(typeof radiusX!=="number"||typeof radiusY!=="number"||typeof angle!=="number"){throw new Error("Invalid arguments: radiusX, radiusY, and angle should be numbers.")}if(!(color instanceof Color)){throw new Error("Invalid color: Expected a Color object.")}if(typeof angle!=="number"){throw new Error("Invalid angle: Expected a number.")}const radianAngle=angle*(Math.PI/180);this.#ctx.beginPath();this.#ctx.ellipse(center.x,center.y,radiusX,radiusY,radianAngle,0,2*Math.PI);this.#ctx.fillStyle=color.getColorAsHex();this.#ctx.fill()}drawEllipseOutline(center,radiusX,radiusY,color=new Color(127,0,0,255),outlineColor=new Color(255,0,0,255),lineWidth=1,angle=0){if(!(center instanceof Vector)){throw new Error("Invalid center: Expected a Vector object.")}if(typeof radiusX!=="number"||typeof radiusY!=="number"||typeof angle!=="number"){throw new Error("Invalid arguments: radiusX, radiusY, and angle should be numbers.")}if(!(color instanceof Color)||!(outlineColor instanceof Color)){throw new Error("Invalid arguments: color and outlineColor should be Color objects.")}if(typeof lineWidth!=="number"){throw new Error("Invalid argument: lineWidth should be a number.")}if(typeof angle!=="number"){throw new Error("Invalid angle: Expected a number.")}const radianAngle=angle*(Math.PI/180);this.#ctx.beginPath();this.#ctx.ellipse(center.x,center.y,radiusX,radiusY,radianAngle,0,2*Math.PI);this.#ctx.fillStyle=color.getColorAsHex();this.#ctx.fill();this.#ctx.lineWidth=lineWidth;this.#ctx.strokeStyle=outlineColor.getColorAsHex();this.#ctx.stroke()}drawLine(start,end,color=new Color(255,0,0,255),lineWidth=1){if(!(start instanceof Vector)||!(end instanceof Vector)){throw new Error("Invalid arguments: Expected Vector objects for start and end positions.")}if(!(color instanceof Color)){throw new Error("Invalid color: Expected a Color object.")}if(typeof lineWidth!=="number"||lineWidth<=0){throw new Error("Invalid lineWidth: Expected a positive number.")}this.#ctx.beginPath();this.#ctx.moveTo(start.x,start.y);this.#ctx.lineTo(end.x,end.y);this.#ctx.lineWidth=lineWidth;this.#ctx.strokeStyle=color.getColorAsHex();this.#ctx.stroke()}drawText(text,position,color=new Color(127,0,0,255),font="16px Arial",rotationAngle=0,center=false){if(typeof text!=="string"){throw new Error("Invalid text: Expected a string.")}if(!(position instanceof Vector)){throw new Error("Invalid position: Expected a Vector object.")}if(!(color instanceof Color)){throw new Error("Invalid color: Expected a Color object.")}if(typeof font!=="string"||font.trim()===""){throw new Error("Invalid font: Expected a non-empty string.")}if(typeof rotationAngle!=="number"){throw new Error("Invalid rotation angle: Expected a number.")}if(typeof center!=="boolean"){throw new Error("Invalid center value: Expected a boolean.")}this.#ctx.save();this.#ctx.font=font;this.#ctx.font=font;this.#ctx.fillStyle=color.getColorAsHex();let textWidth=this.#ctx.measureText(text).width;let textMetrics=this.#ctx.measureText(text);let textHeight=textMetrics.actualBoundingBoxAscent+textMetrics.actualBoundingBoxDescent;if(center){this.#ctx.translate(position.x,position.y);this.#ctx.translate(textWidth/2,textHeight/2);this.#ctx.rotate(rotationAngle*Math.PI/180);this.#ctx.fillText(text,-textWidth/2,-textHeight/2+textMetrics.actualBoundingBoxAscent)}else{this.#ctx.translate(position.x,position.y);this.#ctx.rotate(rotationAngle*Math.PI/180);this.#ctx.fillText(text,0,textMetrics.actualBoundingBoxAscent)}this.#ctx.restore()}toggleFullscreen(){if(!this.isFullscreen()){if(this.#canvas.requestFullscreen){this.#canvas.requestFullscreen()}else if(this.#canvas.mozRequestFullScreen){this.#canvas.mozRequestFullScreen()}else if(this.#canvas.webkitRequestFullscreen){this.#canvas.webkitRequestFullscreen()}else if(this.#canvas.msRequestFullscreen){this.#canvas.msRequestFullscreen()}}else{if(document.exitFullscreen){document.exitFullscreen()}else if(document.mozCancelFullScreen){document.mozCancelFullScreen()}else if(document.webkitExitFullscreen){document.webkitExitFullscreen()}else if(document.msExitFullscreen){document.msExitFullscreen()}}}isFullscreen(){return document.fullscreenElement===this.#canvas||document.mozFullScreenElement===this.#canvas||document.webkitFullscreenElement===this.#canvas||document.msFullscreenElement===this.#canvas}#handleFullscreen(){if(this.isFullscreen()){console.log("Fullscreen mode.");this.#resizeCanvas()}else{console.log("Fullscreen mode disabled.");this.#canvas.style.width=`${this.#canvasWidth}px`;this.#canvas.style.height=`${this.#canvasHeight}px`}}setCanvasSize(newWidth,newHeight){if(typeof newWidth!=="number"||newWidth<=0){throw new Error("Invalid newWidth: Expected a positive number.")}if(typeof newHeight!=="number"||newHeight<=0){throw new Error("Invalid newHeight: Expected a positive number.")}if(this.isFullscreen()){console.log("Cannot resize canvas while in fullscreen mode.");return}this.#canvasWidth=newWidth;this.#canvasHeight=newHeight;this.#canvas.style.width=`${this.#canvasWidth}px`;this.#canvas.style.height=`${this.#canvasHeight}px`}zoomImageData(imageData,position,zoomValue){if(!(imageData instanceof ImageData)){throw new Error("Invalid imageData: Expected an instance of ImageData.")}if(!(position instanceof Vector)){throw new Error("Invalid position: Expected a Vector object.")}if(typeof zoomValue!=="number"||zoomValue<=0){throw new Error("Invalid zoomValue: Expected a positive number.")}const sourceWidth=imageData.width;const sourceHeight=imageData.height;const destImageData=new ImageData(sourceWidth,sourceHeight);for(let y=0;y<sourceHeight;y++){for(let x=0;x<sourceWidth;x++){const srcX=Math.round(position.x+(x-sourceWidth/2)/zoomValue);const srcY=Math.round(position.y+(y-sourceHeight/2)/zoomValue);if(srcX>=0&&srcY>=0&&srcX<sourceWidth&&srcY<sourceHeight){const destIndex=(y*sourceWidth+x)*4;const srcIndex=(srcY*sourceWidth+srcX)*4;destImageData.data[destIndex]=imageData.data[srcIndex];destImageData.data[destIndex+1]=imageData.data[srcIndex+1];destImageData.data[destIndex+2]=imageData.data[srcIndex+2];destImageData.data[destIndex+3]=imageData.data[srcIndex+3]}}}return destImageData}#resizeCanvas(){let windowRatio=window.innerWidth/window.innerHeight;if(windowRatio<this.#aspectRatio){this.#canvas.style.width=window.innerWidth+"px";this.#canvas.style.height=window.innerWidth/this.#aspectRatio+"px"}else{this.#canvas.style.width=window.innerHeight*this.#aspectRatio+"px";this.#canvas.style.height=window.innerHeight+"px"}}createImageData(width,height){if(typeof width!=="number"||width<=0){throw new Error("Invalid width: Expected a positive number.")}if(typeof height!=="number"||height<=0){throw new Error("Invalid height: Expected a positive number.")}return this.ctx.createImageData(width,height)}getImageData(){return this.#ctx.getImageData(0,0,this.#gameWidth,this.#gameHeight)}start(){}update(){}postProcessing(imageData){}ui(){}get gameWidth(){return this.#gameWidth}get gameHeight(){return this.#gameHeight}get ctx(){return this.#ctx}get fps(){return this.#fps}set fpsUpdateRate(rate){if(typeof rate!=="number"||rate<=0){throw new Error("Invalid fpsUpdateRate: Expected a positive number.")}this.#fpsUpdateRate=rate}}class Collision{static lineLineCollision(line1Start,line1End,line2Start,line2End){if(!(line1Start instanceof Vector)||!(line1End instanceof Vector)||!(line2Start instanceof Vector)||!(line2End instanceof Vector)){throw new Error("Invalid arguments: Expected four Vectors.")}const x1=line1Start.x;const y1=line1Start.y;const x2=line1End.x;const y2=line1End.y;const x3=line2Start.x;const y3=line2Start.y;const x4=line2End.x;const y4=line2End.y;const denominator=(x1-x2)*(y3-y4)-(y1-y2)*(x3-x4);if(denominator===0){return{collided:false,point:null}}const t=((x1-x3)*(y3-y4)-(y1-y3)*(x3-x4))/denominator;const u=-((x1-x2)*(y1-y3)-(y1-y2)*(x1-x3))/denominator;if(t>=0&&t<=1&&u>=0&&u<=1){const x=x1+t*(x2-x1);const y=y1+t*(y2-y1);return{collided:true,point:new Vector(x,y)}}return{collided:false,point:null}}static lineCircleCollision(lineStart,lineEnd,circleCenter,circleRadius){if(!(lineStart instanceof Vector)||!(lineEnd instanceof Vector)||!(circleCenter instanceof Vector)){throw new Error("Invalid arguments: Expected Vectors for lineStart, lineEnd, and circleCenter.")}if(typeof circleRadius!=="number"){throw new Error("Invalid argument: Expected a number for circleRadius.")}const lineDirection=lineEnd.copy();lineDirection.sub(lineStart);const startToCenter=circleCenter.copy();startToCenter.sub(lineStart);const projectionLength=startToCenter.dot(lineDirection)/lineDirection.mag();const projection=lineDirection.copy();projection.normalize();projection.mult(projectionLength);if(projectionLength<0){projection.set(lineStart.x,lineStart.y)}else if(projectionLength>lineDirection.mag()){projection.set(lineEnd.x,lineEnd.y)}else{projection.add(lineStart)}const distance=circleCenter.distance(projection);if(distance<=circleRadius){return{collided:true,point:projection}}return{collided:false,point:null}}static lineRectCollision(lineStart,lineEnd,rectPosition,rectWidth,rectHeight,rectRotation){if(!(lineStart instanceof Vector)||!(lineEnd instanceof Vector)||!(rectPosition instanceof Vector)){throw new Error("Invalid arguments: Expected Vectors for lineStart, lineEnd, and rectPosition.")}if(typeof rectWidth!=="number"||typeof rectHeight!=="number"||typeof rectRotation!=="number"){throw new Error("Invalid arguments: Expected numbers for rectWidth, rectHeight, and rectRotation.")}const vertices=this.calculateRectangleVertices(rectPosition,rectWidth,rectHeight,rectRotation);const sides=[{start:vertices[0],end:vertices[1]},{start:vertices[1],end:vertices[2]},{start:vertices[2],end:vertices[3]},{start:vertices[3],end:vertices[0]}];let collided=false;let points=[];for(let side of sides){const result=this.lineLineCollision(lineStart,lineEnd,side.start,side.end);if(result.collided){collided=true;points.push(result.point)}}if(collided){const x=(points[0].x+points[1].x)/2;const y=(points[0].y+points[1].y)/2;return{collided:true,point:new Vector(x,y)}}return{collided:false,point:null}}static circleCircleCollision(circle1Center,circle1Radius,circle2Center,circle2Radius){if(!(circle1Center instanceof Vector)||!(circle2Center instanceof Vector)){throw new Error("Invalid arguments: circle1Center and circle2Center should be Vectors.")}if(typeof circle1Radius!=="number"||typeof circle2Radius!=="number"){throw new Error("Invalid arguments: circle1Radius and circle2Radius should be numbers.")}const distance=circle1Center.distance(circle2Center);const collided=distance<=circle1Radius+circle2Radius;let point=null;if(collided){const totalRadius=circle1Radius+circle2Radius;const ratio=circle1Radius/totalRadius;const collisionX=circle1Center.x+ratio*(circle2Center.x-circle1Center.x);const collisionY=circle1Center.y+ratio*(circle2Center.y-circle1Center.y);point=new Vector(collisionX,collisionY)}return{collided:collided,point:point}}static circleRectCollision(circleCenter,circleRadius,rectCenter,rectWidth,rectHeight,rectRotation){if(!(circleCenter instanceof Vector)||!(rectCenter instanceof Vector)){throw new Error("Invalid arguments: circleCenter and rectCenter should be Vectors.")}if(typeof circleRadius!=="number"||typeof rectWidth!=="number"||typeof rectHeight!=="number"||typeof rectRotation!=="number"){throw new Error("Invalid arguments: circleRadius, rectWidth, rectHeight, and rectRotation should be numbers.")}const rectVertices=this.calculateRectangleVertices(rectCenter,rectWidth,rectHeight,rectRotation);let totalDistance=0;for(let vertex of rectVertices){totalDistance+=circleCenter.distance(vertex)}const maxDistance=Math.sqrt(rectWidth*rectWidth+rectHeight*rectHeight)*2;if(totalDistance<=maxDistance+1){return{collided:true,point:circleCenter}}let collided=false;let closestPoint=null;let minDistance=Infinity;for(let i=0;i<rectVertices.length;i++){const start=rectVertices[i];const end=rectVertices[(i+1)%rectVertices.length];const collision=this.lineCircleCollision(start,end,circleCenter,circleRadius);if(collision.collided){collided=true;const distance=collision.point.distance(circleCenter);if(distance<minDistance){minDistance=distance;closestPoint=collision.point}}}return{collided:collided,point:closestPoint}}static rectRectCollision(rect1Pos,rect1Width,rect1Height,rect1Rotation,rect2Pos,rect2Width,rect2Height,rect2Rotation){if(!(rect1Pos instanceof Vector)||!(rect2Pos instanceof Vector)){throw new Error("Invalid argument: rect1Pos and rect2Pos should be Vectors.")}if(typeof rect1Width!=="number"||typeof rect1Height!=="number"||typeof rect1Rotation!=="number"||typeof rect2Width!=="number"||typeof rect2Height!=="number"||typeof rect2Rotation!=="number"){throw new Error("Invalid arguments: rect1Width, rect1Height, rect1Rotation, rect2Width, rect2Height, and rect2Rotation should be numbers.")}if(rect1Width<=0||rect1Height<=0||rect2Width<=0||rect2Height<=0){throw new Error("Invalid arguments: rect1Width, rect1Height, rect2Width, and rect2Height should be greater than 0.")}const rect1Vertices=this.calculateRectangleVertices(rect1Pos,rect1Width,rect1Height,rect1Rotation);const rect2Vertices=this.calculateRectangleVertices(rect2Pos,rect2Width,rect2Height,rect2Rotation);let axis1=rect1Vertices[1].copy();axis1.sub(rect1Vertices[0]);let axis2=rect1Vertices[3].copy();axis2.sub(rect1Vertices[0]);let axis3=rect2Vertices[1].copy();axis3.sub(rect2Vertices[0]);let axis4=rect2Vertices[3].copy();axis4.sub(rect2Vertices[0]);const axes=[axis1,axis2,axis3,axis4];for(const axis of axes){axis.normalize();let[minA,maxA]=this.projectVerticesOntoAxis(axis,rect1Vertices);let[minB,maxB]=this.projectVerticesOntoAxis(axis,rect2Vertices);if(maxA<minB||maxB<minA){return false}}return true}static calculateRectangleVertices(position,width,height,rotation){if(!(position instanceof Vector)){throw new Error("Invalid argument: position should be a Vector.")}if(typeof width!=="number"||typeof height!=="number"||typeof rotation!=="number"){throw new Error("Invalid arguments: width, height, and rotation should be numbers.")}if(width<=0||height<=0){throw new Error("Invalid arguments: width and height should be greater than 0.")}const halfWidth=width/2;const halfHeight=height/2;const corners=[new Vector(-halfWidth,-halfHeight),new Vector(halfWidth,-halfHeight),new Vector(halfWidth,halfHeight),new Vector(-halfWidth,halfHeight)];rotation=GameMath.degreesToRadians(rotation);const cosTheta=Math.cos(rotation);const sinTheta=Math.sin(rotation);const vertices=corners.map(corner=>{const x=corner.x*cosTheta-corner.y*sinTheta+position.x;const y=corner.x*sinTheta+corner.y*cosTheta+position.y;return new Vector(x,y)});return vertices}static projectVerticesOntoAxis(axis,vertices){if(!(axis instanceof Vector)){throw new Error("Invalid argument: axis should be a Vector.")}if(!Array.isArray(vertices)||vertices.some(vertex=>!(vertex instanceof Vector))){throw new Error("Invalid argument: vertices should be an array of Vectors.")}let min=axis.dot(vertices[0]);let max=min;for(let i=1;i<vertices.length;i++){const projection=axis.dot(vertices[i]);min=Math.min(min,projection);max=Math.max(max,projection)}return[min,max]}}class Color{constructor(r,g,b,a){this.r=~~r;this.g=~~g;this.b=~~b;this.a=~~a}mix(color,ratio){if(!(color instanceof Color)){throw new Error("Color.mix requires a Color.")}if(ratio<0||ratio>1){throw new Error("The ratio must be between 0 and 1!")}this.r=~~(this.r*(1-ratio)+color.r*ratio);this.g=~~(this.g*(1-ratio)+color.g*ratio);this.b=~~(this.b*(1-ratio)+color.b*ratio);this.a=~~(this.a*(1-ratio)+color.a*ratio)}add(color){if(!(color instanceof Color)){throw new Error("Color.add requires a Color.")}this.r=Math.min(255,this.r+color.r);this.g=Math.min(255,this.g+color.g);this.b=Math.min(255,this.b+color.b);this.a=Math.min(255,this.a+color.a)}sub(color){if(!(color instanceof Color)){throw new Error("Color.sub requires a Color.")}this.r=Math.max(0,this.r-color.r);this.g=Math.max(0,this.g-color.g);this.b=Math.max(0,this.b-color.b);this.a=Math.max(0,this.a-color.a)}mult(factor){if(factor<0||factor>1){throw new Error("The factor must be between 0 and 1!")}this.r=~~(this.r*factor);this.g=~~(this.g*factor);this.b=~~(this.b*factor);this.a=~~(this.a*factor)}div(color){if(!(color instanceof Color)){throw new Error("Color.div requires a Color.")}if(color.r===0||color.g===0||color.b===0||color.a===0){throw new Error("Cannot divide by a Color with a zero component.")}this.r=Math.max(0,Math.min(255,~~(this.r/color.r)));this.g=Math.max(0,Math.min(255,~~(this.g/color.g)));this.b=Math.max(0,Math.min(255,~~(this.b/color.b)));this.a=Math.max(0,Math.min(255,~~(this.a/color.a)))}getColorAsHex(){const r=this.r.toString(16).padStart(2,"0");const g=this.g.toString(16).padStart(2,"0");const b=this.b.toString(16).padStart(2,"0");const a=this.a.toString(16).padStart(2,"0");return`#${r}${g}${b}${a}`}intToColor(int){if(typeof int!=="number"||!Number.isInteger(int)||int<0||int>4294967295){throw new Error("Invalid integer: Expected an integer between 0 and 4294967295.")}this.r=int&255;this.g=(int&65280)>>8;this.b=(int&16711680)>>16;this.a=(int&4278190080)>>24}getColorAs32Int(){return this.a<<24|this.b<<16|this.g<<8|this.r}copy(){return new Color(this.r,this.g,this.b,this.a)}}class GameMath{static clamp(value,min,max){if(typeof value!=="number"||typeof min!=="number"||typeof max!=="number"){throw new Error("Invalid arguments: Expected numbers for value, min, and max.")}return Math.max(min,Math.min(max,value))}static lerp(a,b,t){if(typeof a!=="number"||typeof b!=="number"||typeof t!=="number"){throw new Error("Invalid arguments: Expected numbers for a, b, and t.")}return(1-t)*a+t*b}static remap(value,inputMin,inputMax,outputMin,outputMax){if(typeof value!=="number"||typeof inputMin!=="number"||typeof inputMax!=="number"||typeof outputMin!=="number"||typeof outputMax!=="number"){throw new Error("Invalid arguments: Expected numbers for value, inputMin, inputMax, outputMin, and outputMax.")}return outputMin+(value-inputMin)/(inputMax-inputMin)*(outputMax-outputMin)}static distance(x1,y1,x2,y2){if(typeof x1!=="number"||typeof y1!=="number"||typeof x2!=="number"||typeof y2!=="number"){throw new Error("Invalid arguments: Expected numbers for x1, y1, x2, and y2.")}const dx=x2-x1;const dy=y2-y1;return Math.sqrt(dx*dx+dy*dy)}static angle(x1,y1,x2,y2){if(typeof x1!=="number"||typeof y1!=="number"||typeof x2!=="number"||typeof y2!=="number"){throw new Error("Invalid arguments: Expected numbers for x1, y1, x2, and y2.")}return Math.atan2(y2-y1,x2-x1)}static degreesToRadians(degrees){if(typeof degrees!=="number"){throw new Error("Invalid argument: Expected a number for degrees.")}return degrees*(Math.PI/180)}static radiansToDegrees(radians){if(typeof radians!=="number"){throw new Error("Invalid argument: Expected a number for radians.")}return radians*(180/Math.PI)}}class Input{#canvasId;#canvas;#keys;#position;#mouseButtons;#gamepads=[];#gamepadButtonStates=[];#gamepadAxesStates=[];#gamepadConnected=[];#touches=[];constructor(canvasId){if(typeof canvasId!=="string"){throw new Error("Invalid canvasId provided. Ensure it corresponds to an existing canvas element.")}this.#position=new Vector(0,0);this.#canvasId=canvasId;this.#mouseButtons={[MouseButtons.LEFT]:false,[MouseButtons.MIDDLE]:false,[MouseButtons.RIGHT]:false,[MouseButtons.BACK]:false,[MouseButtons.FORWARD]:false};this.#keys={}}init(){this.#canvas=document.getElementById(this.#canvasId);if(!this.#canvas){throw new Error("Failed to initialize. Ensure canvasId corresponds to an existing canvas element.")}this.#initializeEventListeners()}#initializeEventListeners(){this.#canvas.addEventListener("mousemove",e=>this.onMouseMove(e),false);this.#canvas.addEventListener("mousemove",e=>this.#updatePosition(e),false);this.#canvas.addEventListener("mousedown",e=>this.onMouseButtonDown(e),false);this.#canvas.addEventListener("mousedown",e=>this.#handleMouseDown(e),false);this.#canvas.addEventListener("mouseup",e=>this.onMouseButtonUp(e),false);this.#canvas.addEventListener("mouseup",e=>this.#handleMouseUp(e),false);this.#canvas.addEventListener("wheel",e=>this.onMouseWheel(e),false);window.addEventListener("keydown",e=>this.#handleKeyDown(e),false);window.addEventListener("keyup",e=>this.#handleKeyUp(e),false);window.addEventListener("keydown",e=>this.onKeyDown(e),false);window.addEventListener("keyup",e=>this.onKeyUp(e),false);window.addEventListener("gamepadconnected",e=>this.#handleGamepadConnected(e),false);window.addEventListener("gamepaddisconnected",e=>this.#handleGamepadDisconnected(e),false);this.#canvas.addEventListener("touchstart",e=>this.#handleTouchStart(e),false);this.#canvas.addEventListener("touchmove",e=>this.#handleTouchMove(e),false);this.#canvas.addEventListener("touchend",e=>this.#handleTouchEnd(e),false)}#updatePosition(e){const rect=this.#canvas.getBoundingClientRect();let isInFullScreen=(document.fullscreenElement||document.webkitFullscreenElement||document.mozFullScreenElement||document.msFullscreenElement)===this.#canvas;if(isInFullScreen){const canvasAspectRatio=this.#canvas.width/this.#canvas.height;const screenAspectRatio=window.innerWidth/window.innerHeight;let scaleX,scaleY,offsetX,offsetY;if(canvasAspectRatio>screenAspectRatio){scaleX=rect.width/this.#canvas.width;scaleY=scaleX;offsetX=0;offsetY=(window.innerHeight-this.#canvas.height*scaleY)/2}else{scaleY=rect.height/this.#canvas.height;scaleX=scaleY;offsetY=0;offsetX=(window.innerWidth-this.#canvas.width*scaleX)/2}this.#position.x=(e.clientX-rect.left-offsetX)*(1/scaleX);this.#position.y=(e.clientY-rect.top-offsetY)*(1/scaleY)}else{const scaleX=this.#canvas.width/rect.width;const scaleY=this.#canvas.height/rect.height;this.#position.x=(e.clientX-rect.left)*scaleX;this.#position.y=(e.clientY-rect.top)*scaleY}}#handleMouseDown(e){switch(e.button){case 0:this.#mouseButtons[MouseButtons.LEFT]=true;break;case 1:this.#mouseButtons[MouseButtons.MIDDLE]=true;break;case 2:this.#mouseButtons[MouseButtons.RIGHT]=true;break;case 3:this.#mouseButtons[MouseButtons.BACK]=true;break;case 4:this.#mouseButtons[MouseButtons.FORWARD]=true;break;default:break}}#handleMouseUp(e){switch(e.button){case 0:this.#mouseButtons[MouseButtons.LEFT]=false;break;case 1:this.#mouseButtons[MouseButtons.MIDDLE]=false;break;case 2:this.#mouseButtons[MouseButtons.RIGHT]=false;break;case 3:this.#mouseButtons[MouseButtons.BACK]=false;break;case 4:this.#mouseButtons[MouseButtons.FORWARD]=false;break;default:break}}onMouseMove(e){}onMouseWheel(e){}onMouseButtonDown(e){}onMouseButtonUp(e){}getMouseButton(button){if(!this.#mouseButtons.hasOwnProperty(button)){throw new Error(`Invalid mouse button: ${button}`)}return this.#mouseButtons[button]}getMousePosition(){return this.#position.copy()}#handleKeyDown(e){this.#keys[e.code]=true}#handleKeyUp(e){this.#keys[e.code]=false}onKeyDown(e){}onKeyUp(e){}getKey(keyCode){if(typeof keyCode!=="string"){throw new Error("Invalid keyCode. It should be a string.")}return!!this.#keys[keyCode]}#handleGamepadConnected(event){console.log(`GamePad ${event.gamepad.index} connected.`);const gamepadIndex=event.gamepad.index;this.#gamepads[gamepadIndex]=event.gamepad;this.#gamepadButtonStates[gamepadIndex]=new Array(event.gamepad.buttons.length).fill(false);this.#gamepadAxesStates[gamepadIndex]=new Array(event.gamepad.axes.length).fill(0);this.#attachGamepadListeners()}#handleGamepadDisconnected(event){console.log(`GamePad ${event.gamepad.index} disconnected.`);const disconnectedGamepadIndex=event.gamepad.index;this.#gamepads[disconnectedGamepadIndex]=undefined;this.#gamepadButtonStates[disconnectedGamepadIndex]=[];this.#gamepadAxesStates[disconnectedGamepadIndex]=[]}#attachGamepadListeners(){const AXIS_CHANGE_THRESHOLD=.01;const handleButtonsChange=gamepad=>{gamepad.buttons.forEach((button,index)=>{if(this.#gamepadButtonStates[gamepad.index][index]!==button.pressed){this.#gamepadButtonStates[gamepad.index][index]=button.pressed;if(button.pressed){this.onGamepadButtonPressed(index,gamepad.index)}else{this.onGamepadButtonReleased(index,gamepad.index)}}})};const handleAxesChange=gamepad=>{gamepad.axes.forEach((axis,index)=>{if(Math.abs(this.#gamepadAxesStates[gamepad.index][index]-axis)>AXIS_CHANGE_THRESHOLD){this.#gamepadAxesStates[gamepad.index][index]=axis;this.onGamepadAxisChanged(index,axis,gamepad.index)}})};const pollGamepads=()=>{const gamepads=navigator.getGamepads();for(const gamepad of gamepads){if(gamepad){handleButtonsChange(gamepad);handleAxesChange(gamepad)}}requestAnimationFrame(pollGamepads)};requestAnimationFrame(pollGamepads)}getGamepadButton(gamepadIndex,buttonIndex){if(!this.#gamepads[gamepadIndex]){throw new Error(`No gamepad connected at index ${gamepadIndex}.`)}if(buttonIndex<0||buttonIndex>=this.#gamepads[gamepadIndex].buttons.length){throw new Error(`Invalid button index. Valid indices are between 0 and ${this.#gamepads[gamepadIndex].buttons.length-1}.`)}return this.#gamepadButtonStates[gamepadIndex][buttonIndex]}onGamepadButtonPressed(buttonIndex,gamepadIndex){console.log(`Button ${buttonIndex} pressed on gamepad ${gamepadIndex}`)}onGamepadButtonReleased(buttonIndex,gamepadIndex){console.log(`Button ${buttonIndex} released on gamepad ${gamepadIndex}`)}onGamepadAxisChanged(axisIndex,value,gamepadIndex){console.log(`Axis ${axisIndex} value changed to ${value} on gamepad ${gamepadIndex}`)}isGamepadConnected(gamepadIndex){if(gamepadIndex<0||gamepadIndex>=this.#gamepads.length){return false}return this.#gamepads[gamepadIndex]!==undefined}#handleTouchStart(e){e.preventDefault();this.#touches=[...e.touches];this.onTouchStart(e)}#handleTouchMove(e){e.preventDefault();this.#touches=[...e.touches];this.onTouchMove(e)}#handleTouchEnd(e){e.preventDefault();this.#touches=[...e.touches];this.onTouchEnd(e)}onTouchStart(e){}onTouchMove(e){}onTouchEnd(e){}getTouches(){return this.#touches}}const KeyCode={A:"KeyA",B:"KeyB",C:"KeyC",D:"KeyD",E:"KeyE",F:"KeyF",G:"KeyG",H:"KeyH",I:"KeyI",J:"KeyJ",K:"KeyK",L:"KeyL",M:"KeyM",N:"KeyN",O:"KeyO",P:"KeyP",Q:"KeyQ",R:"KeyR",S:"KeyS",T:"KeyT",U:"KeyU",V:"KeyV",W:"KeyW",X:"KeyX",Y:"KeyY",Z:"KeyZ",ZERO:"Digit0",ONE:"Digit1",TWO:"Digit2",THREE:"Digit3",FOUR:"Digit4",FIVE:"Digit5",SIX:"Digit6",SEVEN:"Digit7",EIGHT:"Digit8",NINE:"Digit9",ESCAPE:"Escape",SPACE:"Space",ENTER:"Enter",SHIFT_LEFT:"ShiftLeft",SHIFT_RIGHT:"ShiftRIGHT",CONTROL_LEFT:"ControlLeft",CONTROL_RIGHT:"ControlRight",ALT_LEFT:"AltLeft",ALT_RIGHT:"AltRight",ARROW_UP:"ArrowUp",ARROW_DOWN:"ArrowDown",ARROW_LEFT:"ArrowLeft",ARROW_RIGHT:"ArrowRight",NUMPAD_0:"Numpad0",NUMPAD_1:"Numpad1",NUMPAD_2:"Numpad2",NUMPAD_3:"Numpad3",NUMPAD_4:"Numpad4",NUMPAD_5:"Numpad5",NUMPAD_6:"Numpad6",NUMPAD_7:"Numpad7",NUMPAD_8:"Numpad8",NUMPAD_9:"Numpad9",NUMPAD_ADD:"NumpadAdd",NUMPAD_SUBTRACT:"NumpadSubtract",NUMPAD_MULTIPLY:"NumpadMultiply",NUMPAD_DIVIDE:"NumpadDivide",NUMPAD_DECIMAL:"NumpadDecimal",NUMPAD_ENTER:"NumpadEnter",NUMPAD_CLEAR:"NumpadClear",NUMPAD_EQUALS:"NumpadEqual"};const GamepadButtons={A:0,B:1,X:2,Y:3,LEFT_BUMPER:4,RIGHT_BUMPER:5,LEFT_TRIGGER:6,RIGHT_TRIGGER:7,BACK:8,START:9,LEFT_STICK_CLICK:10,RIGHT_STICK_CLICK:11,DPAD_UP:12,DPAD_DOWN:13,DPAD_LEFT:14,DPAD_RIGHT:15,HOME:16,LEFT_STICK_X:0,LEFT_STICK_Y:1,RIGHT_STICK_X:2,RIGHT_STICK_Y:3};const MouseButtons={LEFT:0,MIDDLE:1,RIGHT:2,BACK:3,FORWARD:4,WHEEL_UP:"WHEEL_UP",WHEEL_DOWN:"WHEEL_DOWN"};class Light{constructor(x,y,dist,maxBrightness,gradientValue){if(typeof x!=="number"||typeof y!=="number"||typeof dist!=="number"){throw new Error("Invalid light parameters: x, y, and dist must be numbers.")}if(typeof maxBrightness!=="number"||maxBrightness<0||maxBrightness>1){throw new Error("Invalid maxBrightness: must be a number between 0 and 1.")}if(typeof gradientValue!=="number"||gradientValue<0||gradientValue>1){throw new Error("Invalid gradientValue: must be a number between 0 and 1.")}this.x=x;this.y=y;this.dist=dist;this.maxBrightness=maxBrightness;this.gradientValue=gradientValue}moveTo(x,y){if(typeof x!=="number"||typeof y!=="number"){throw new Error("Invalid parameters: x and y must be numbers.")}this.x=x;this.y=y}setDistance(dist){if(typeof dist!=="number"){throw new Error("Invalid parameter: dist must be a number.")}this.dist=dist}setMaxBrightness(maxBrightness){if(typeof maxBrightness!=="number"){throw new Error("Invalid maxBrightness: must be a number.")}this.maxBrightness=this.#clamp(maxBrightness,0,1,"maxBrightness")}setGradientValue(gradientValue){if(typeof gradientValue!=="number"){throw new Error("Invalid gradientValue: must be a number.")}this.gradientValue=this.#clamp(gradientValue,0,1,"gradientValue")}#clamp(value,min,max,name){if(value<min||value>max){console.warn(`Value of ${name} should be between ${min} and ${max}. Clamping value.`);return Math.max(min,Math.min(max,value))}return value}}class Physics{#nodes;#connections;#areaWidth;#areaHeight;#gravity;#subSteps;#MAX_DELTA;#responseCoef;#grid;#biggestNodeForGrid;constructor(areaWidth,areaHeight,gravity=new Vector(0,9.81),subSteps=2,responseCoef=.75,max_delta=.045){if(typeof areaWidth!=="number"||typeof areaHeight!=="number"||typeof max_delta!=="number"){throw new Error("max_delta, areaWidth and areaHeight must be numbers.")}if(!(gravity instanceof Vector)){throw new Error("gravity must be an instance of Vector.")}this.#nodes=[];this.#connections=[];this.#areaWidth=areaWidth;this.#areaHeight=areaHeight;this.#gravity=gravity;this.#MAX_DELTA=max_delta;this.#subSteps=~~subSteps;this.#responseCoef=GameMath.clamp(responseCoef,0,1);this.#biggestNodeForGrid=10;this.#grid=new SpatialGrid(this.#biggestNodeForGrid*2,areaWidth*1,areaHeight*1)}update(deltaTime){if(typeof deltaTime!=="number"){throw new Error("deltaTime must be a number.")}const deltaTimeSubStep=deltaTime/this.#subSteps;for(let step=0;step<this.#subSteps;step++){for(let node of this.#nodes){if(deltaTime>this.#MAX_DELTA)continue;node.update(deltaTimeSubStep,this.#gravity)}this.#resolveConnections();this.#resolveCollisions(deltaTimeSubStep)}}addPhysicsNode(node){if(!(node instanceof PhysicsNode)){throw new Error("node must be an instance of PhysicsNode.")}if(node.radius>this.#biggestNodeForGrid){this.#biggestNodeForGrid=node.radius;this.#grid=new SpatialGrid(this.#biggestNodeForGrid*2,this.#areaWidth*1,this.#areaHeight*1);console.warn("Optimization grid cell changed to fit "+node.name+". Performance might be worse.")}this.#nodes.push(node)}makePhysicsNode(position,radius,mass=1,bounciness=0,airFriction=.999,surfaceFriction=.75,locked=false,collider=true,name="PhysicsNode"){if(!(position&&position.copy)){throw new Error("Position must be a valid object with a copy method (e.g., a Vector instance).")}if(typeof radius!=="number"){throw new Error("Radius must be a number.")}if(typeof mass!=="number"){throw new Error("Mass must be a number.")}if(typeof bounciness!=="number"){throw new Error("Bounciness must be a number.")}if(typeof airFriction!=="number"){throw new Error("AirFriction must be a number.")}if(typeof surfaceFriction!=="number"){throw new Error("SurfaceFriction must be a number.")}if(typeof locked!=="boolean"){throw new Error("Locked must be a boolean.")}if(typeof collider!=="boolean"){throw new Error("Collider must be a boolean.")}if(typeof name!=="string"){throw new Error("Name must be a string.")}if(radius>this.#biggestNodeForGrid){this.#biggestNodeForGrid=radius;this.#grid=new SpatialGrid(this.#biggestNodeForGrid*2,this.#areaWidth*1,this.#areaHeight*1);console.warn("Optimization grid cell changed to fit new node. Performance might be worse.")}const node=new PhysicsNode(position,radius,mass,bounciness,airFriction,surfaceFriction,locked,collider,name);this.#nodes.push(node)}addPhysicsConnection(connection){if(!(connection instanceof PhysicsConnection)){throw new Error("connection must be an instance of PhysicsConnection.")}this.#connections.push(connection)}makePhysicsConnection(node1,node2,restingDistance,collider=true,name="PhysicsConnection"){if(!(node1 instanceof PhysicsNode)||!(node2 instanceof PhysicsNode)){throw new Error("Both node1 and node2 must be instances of PhysicsNode.")}if(typeof restingDistance!=="number" && restingDistance != null){throw new Error("restingDistance must be a number.")}if(typeof collider!=="boolean"){throw new Error("collider must be a boolean value.")}if(typeof name!=="string"){throw new Error("name must be a string.")}const connection=new PhysicsConnection(node1,node2,restingDistance,collider,name);this.#connections.push(connection)}removePhysicsNode(node){if(!(node instanceof PhysicsNode)){throw new Error("node must be an instance of PhysicsNode.")}const index=this.#nodes.indexOf(node);if(index!==-1){this.#nodes.splice(index,1)}else{throw new Error("The specified node does not exist in the physics simulation.")}}removePhysicsConnection(connection){if(!(connection instanceof PhysicsConnection)){throw new Error("connection must be an instance of PhysicsConnection.")}const index=this.#connections.indexOf(connection);if(index!==-1){this.#connections.splice(index,1)}else{throw new Error("The specified connection does not exist in the physics simulation.")}}#resolveConnections(){for(let connection of this.#connections){connection.solve()}}#resolveCollisions(deltaTime){this.#grid.clear();for(let node of this.#nodes){this.#grid.insert(node)}for(let node of this.#nodes){this.#checkCollisionWithBoundary(node,deltaTime);const candidates=this.#grid.getNearby(node);for(let candidate of candidates){if(node!==candidate&&this.#checkCollisionNodeNode(node,candidate)&&node.collider&&candidate.collider){this.#resolveCollisionNodeNode(node,candidate)}}}for(let connection of this.#connections){const candidates=this.#grid.getNodesForConnection(connection.node1,connection.node2);for(let candidate of candidates){if(connection.collider&&!(connection.node1==candidate||connection.node2==candidate)&&candidate.collider){if(connection.parent!=null&&connection.parent.solidShape){if(this.#checkCollisionNodeShape(candidate,connection.parent)&&this.#closestConnectionToNode(candidate,connection.parent)===connection){connection.parent.onCollision();const closestPos=this.#closestPointOnConnection(candidate.position,connection.node1.position,connection.node2.position);const dir=Vector.sub(candidate.position,closestPos).mult(-1.1);candidate.position.add(dir)}}if(connection.parent!=null&&this.#checkCollisionNodeConnection(candidate,connection))this.#resolveCollisionNodeConnection(candidate,connection)}}}}#checkCollisionNodeNode(node1,node2){if(!node1.collider||!node2.collider)return false;const distance=node1.position.distance(node2.position);return distance<=node1.radius+node2.radius}#checkCollisionNodeConnection(node,connection){const closestPoint=this.#closestPointOnConnection(node.position,connection.node1.position,connection.node2.position);const distanceToConnection=node.position.distance(closestPoint);return distanceToConnection<=node.radius}#checkCollisionNodeShape(node,shape){if(node.locked)return false;let intersectCount=0;shape.connections.forEach(connection=>{const cn1=connection.node1;const cn2=connection.node2;if(cn1.position.y>node.position.y!==cn2.position.y>node.position.y&&connection.collider){const intersectX=cn1.position.x+(node.position.y-cn1.position.y)*(cn2.position.x-cn1.position.x)/(cn2.position.y-cn1.position.y);if(node.position.x<intersectX){intersectCount++}}});return intersectCount%2!==0}#resolveCollisionNodeNode(node1,node2){if(!node1.collider||!node2.collider)return;node1.onCollision(node2);node2.onCollision(node1);if(node1.locked&&node2.locked)return;let responseCoef=this.#responseCoef;let difference=Vector.sub(node1.position.copy(),node2.position.copy());let dist2=Math.pow(difference.x,2)+Math.pow(difference.y,2);let minDist=node1.radius+node2.radius;let distance=GameMath.clamp(Math.sqrt(dist2),1,this.areaWidth+this.areaHeight);let n=Vector.div(difference.copy(),distance);let avgBounciness=(node1.bounciness+node2.bounciness)/2*10;let delta=.5*responseCoef*(distance-minDist)*(1+avgBounciness);if(node1.locked){node2.position.add(n.copy().mult(delta))}else if(node2.locked){node1.position.sub(n.copy().mult(delta))}else{let massRatio1=node1.mass/(node1.mass+node2.mass);let massRatio2=node2.mass/(node1.mass+node2.mass);node1.position.sub(n.copy().mult(massRatio2*delta));node2.position.add(n.copy().mult(massRatio1*delta))}}#resolveCollisionNodeConnection(node,connection){node.onCollision(connection);connection.onCollision();connection.parent.onCollision();let closestPoint=this.#closestPointOnConnection(node.position,connection.node1.position,connection.node2.position);let overlap=node.radius-node.position.distance(closestPoint);if(overlap<=0)return;const direction=Vector.sub(closestPoint,node.position);if(direction.mag()<1e-6)return;direction.normalize();const avgBounciness=(node.bounciness+connection.node1.bounciness+connection.node2.bounciness)/3*10;const responseCoef=this.#responseCoef;overlap*=(1+avgBounciness)*responseCoef;const NodeBias=node.mass;const parentBias=connection.node1.mass+connection.node2.mass;const totalBias=NodeBias+parentBias;const NodeAdjustment=overlap*parentBias/totalBias;const physicsObjectAdjustment=overlap*NodeBias/totalBias;const distanceToNode1=node.position.distance(connection.node1.position);const distanceToNode2=node.position.distance(connection.node2.position);const totalDistance=distanceToNode1+distanceToNode2;const proportionForNode1=distanceToNode2/totalDistance;const proportionForNode2=distanceToNode1/totalDistance;if(!node.locked){node.position.sub(direction.copy().mult(NodeAdjustment))}if(!connection.node1.locked)connection.node1.position.add(direction.copy().mult(physicsObjectAdjustment*proportionForNode1));if(!connection.node2.locked)connection.node2.position.add(direction.copy().mult(physicsObjectAdjustment*proportionForNode2))}#closestPointOnConnection(point,ConnectionStart,ConnectionEnd){const ConnectionLengthSquared=ConnectionStart.distance(ConnectionEnd)*ConnectionStart.distance(ConnectionEnd);if(ConnectionLengthSquared===0)return ConnectionStart.copy();const t=Math.max(0,Math.min(1,Vector.dot(point.copy().sub(ConnectionStart),ConnectionEnd.copy().sub(ConnectionStart))/ConnectionLengthSquared));const projection=ConnectionStart.copy().add(ConnectionEnd.copy().sub(ConnectionStart).mult(t));return projection}#closestConnectionToNode(node,shape){let closestConnection=null;let closestDistance=Infinity;shape.connections.forEach(connection=>{if(connection.collider){const pointOnConnection=this.#closestPointOnConnection(node.position,connection.node1.position,connection.node2.position);const distance=node.position.distance(pointOnConnection);if(distance<closestDistance){closestDistance=distance;closestConnection=connection}}});return closestConnection}#checkCollisionWithBoundary(node,deltaTime){let velocity=Vector.sub(node.position,node.prevPosition);let overlap=0;const adjustedBounciness=node.bounciness;const adjustedSurfaceFriction=Math.pow(node.surfaceFriction,deltaTime);if(node.position.y+node.radius>=this.areaHeight){overlap=node.position.y+node.radius-this.areaHeight;node.position.y-=overlap*(1+adjustedBounciness);velocity.y*=-adjustedBounciness;velocity.x*=adjustedSurfaceFriction;node.prevPosition=Vector.sub(node.position,velocity)}if(node.position.y-node.radius<=0){overlap=node.radius-node.position.y;node.position.y+=overlap*(1+adjustedBounciness);velocity.y*=-adjustedBounciness;node.prevPosition=Vector.sub(node.position,velocity)}if(node.position.x-node.radius<=0){overlap=node.radius-node.position.x;node.position.x+=overlap*(1+adjustedBounciness);velocity.x*=-adjustedBounciness;node.prevPosition=Vector.sub(node.position,velocity)}if(node.position.x+node.radius>=this.areaWidth){overlap=node.position.x+node.radius-this.areaWidth;node.position.x-=overlap*(1+adjustedBounciness);velocity.x*=-adjustedBounciness;node.prevPosition=Vector.sub(node.position,velocity)}}get nodes(){return this.#nodes}get connections(){return this.#connections}get areaWidth(){return this.#areaWidth}get areaHeight(){return this.#areaHeight}get gravity(){return this.#gravity}get MAX_DELTA(){return this.#MAX_DELTA}get grid(){return this.#grid}}class PhysicsConnection{#name;#node1;#node2;#restingDistance;#resolveFactor;#collider;#parent;constructor(node1,node2,restingDistance,collider=true,name="PhysicsConnection",resolveFactor=1){if(!(node1 instanceof PhysicsNode)||!(node2 instanceof PhysicsNode)){throw new Error("Both node1 and node2 must be instances of PhysicsNode.")}if(typeof restingDistance!=="number" && restingDistance != null){throw new Error("restingDistance must be a number.")}if(typeof collider!=="boolean"){throw new Error("collider must be a boolean value.")}if(typeof name!=="string"){throw new Error("name must be a string.")}if(typeof resolveFactor!=="number"){throw new Error("resolveFactor must be a number.")}this.#name=name;this.#node1=node1;this.#node2=node2;this.#restingDistance=restingDistance||node1.position.distance(node2.position);this.#collider=collider;this.#resolveFactor=GameMath.clamp(resolveFactor,0,1);this.#parent=null}onCollision(other){}solve(){let dir=Vector.sub(this.#node1.position,this.#node2.position);let currentDistance=dir.mag();dir.normalize();let deviation=currentDistance-this.#restingDistance;let correctionOffset;correctionOffset=deviation;let offset=correctionOffset/2;let totalMass=this.#node1.mass+this.#node2.mass;let w1=this.#node2.mass/totalMass;let w2=this.#node1.mass/totalMass;let offset1=new Vector(dir.x*offset*w2,dir.y*offset*w2).mult(this.#resolveFactor);let offset2=new Vector(dir.x*offset*w1,dir.y*offset*w1).mult(this.#resolveFactor);if(!this.#node1.locked){this.#node1.position.sub(offset1)}if(!this.#node2.locked){this.#node2.position.add(offset2)}}get node1(){return this.#node1}get node2(){return this.#node2}get name(){return this.#name}set name(value){if(typeof value!=="string"){throw new Error("name must be a string.")}this.#name=value}get restingDistance(){return this.#restingDistance}set restingDistance(value){if(typeof value!=="number"){throw new Error("restingDistance must be a number.")}this.#restingDistance=value}get resolveFactor(){return this.#resolveFactor}set resolveFactor(value){if(typeof value!=="number"){throw new Error("resolveFactor must be a number.")}this.#resolveFactor=value}get collider(){return this.#collider}set collider(value){if(typeof value!=="boolean"){throw new Error("collider must be a boolean value.")}this.#collider=value}get parent(){return this.#parent}set parent(value){if(!(value instanceof PhysicsObject)&&value!==null){throw new Error("Parent must be an instance of PhysicsObject or null.")}this.#parent=value}}class PhysicsNode{#name=name;#position;#prevPosition;#rotation;#rotationSpeed;#radius;#mass;#bounciness;#airFriction;#surfaceFriction;#forces;#maxVelocityMagnitude;#locked;#collider;#parent;constructor(position,radius,mass=1,bounciness=0,airFriction=.999,surfaceFriction=.75,locked=false,collider=true,name="PhysicsNode",maxVelocity=Infinity){if(!(position&&position.copy)){throw new Error("Position must be a valid object with a copy method (e.g., a Vector instance).")}if(typeof radius!=="number"){throw new Error("Radius must be a number.")}if(typeof mass!=="number"||mass<=0){throw new Error("Mass must be a number greater than 0.")}if(typeof bounciness!=="number"){throw new Error("Bounciness must be a number.")}if(typeof airFriction!=="number"){throw new Error("AirFriction must be a number.")}if(typeof surfaceFriction!=="number"){throw new Error("SurfaceFriction must be a number.")}if(typeof locked!=="boolean"){throw new Error("Locked must be a boolean.")}if(typeof collider!=="boolean"){throw new Error("Collider must be a boolean.")}if(typeof name!=="string"){throw new Error("Name must be a string.")}this.#name=name;this.#position=position.copy();this.#prevPosition=position.copy();this.#rotation=0;this.#rotationSpeed=Math.PI*.5/radius;this.#radius=radius;this.#mass=mass;this.#bounciness=GameMath.clamp(bounciness,0,1);this.#airFriction=GameMath.clamp(airFriction,0,1);this.#surfaceFriction=GameMath.clamp(surfaceFriction,0,1);this.#forces=new Vector(0,0);this.#maxVelocityMagnitude=maxVelocity;this.#locked=locked;this.#collider=collider;this.#parent=null}addForce(force){if(!(force&&typeof force==="object")){throw new Error("Force must be a valid object (e.g., a Vector instance).")}this.#forces=Vector.add(this.#forces,force)}update(deltaTime,gravity){if(typeof deltaTime!=="number"){throw new Error("deltaTime must be a number.")}if(this.#locked){this.#forces.set(0,0);return}let gravityForce=Vector.mult(gravity,this.mass);this.#forces.add(gravityForce.mult(400));let acceleration=Vector.div(this.#forces,this.mass);let accelerationDisplacement=Vector.mult(acceleration,.5*deltaTime*deltaTime);let displacement=Vector.sub(this.#position,this.#prevPosition);displacement=this.#clampVelocity(this.#maxVelocityMagnitude,deltaTime);const adjustedAirFriction=Math.pow(this.airFriction,deltaTime);displacement.x*=adjustedAirFriction;displacement.y*=adjustedAirFriction;let newPos=Vector.add(this.#position,displacement);newPos.add(accelerationDisplacement);this.#prevPosition=this.#position.copy();this.#position=newPos;this.#forces.set(0,0);this.#rotation+=this.#rotationSpeed*(this.#position.x-this.#prevPosition.x)}onCollision(other){}#clampVelocity(maxVelocity,deltaTime){let displacement=Vector.sub(this.#position,this.#prevPosition);let effectiveVelocity=Vector.div(displacement,deltaTime);let magnitude=effectiveVelocity.mag();if(magnitude>maxVelocity){let scale=maxVelocity/magnitude;effectiveVelocity=Vector.mult(effectiveVelocity,scale);displacement=Vector.mult(effectiveVelocity,deltaTime)}return displacement}get name(){return this.#name}get position(){return this.#position}get prevPosition(){return this.#prevPosition}get rotation(){return this.#rotation}get rotationSpeed(){return this.#rotationSpeed}get radius(){return this.#radius}get mass(){return this.#mass}get bounciness(){return this.#bounciness}get airFriction(){return this.#airFriction}get surfaceFriction(){return this.#surfaceFriction}get forces(){return this.#forces}get maxVelocityMagnitude(){return this.#maxVelocityMagnitude}get locked(){return this.#locked}get collider(){return this.#collider}get parent(){return this.#parent}set name(value){if(typeof value!=="string"){throw new Error("name must be a string.")}this.#name=value}set position(value){if(!(value&&value.copy)){throw new Error("Position must be a valid object with a copy method (e.g., a Vector instance).")}this.#position=value.copy()}set prevPosition(value){if(!(value&&value.copy)){throw new Error("Previous position must be a valid object with a copy method (e.g., a Vector instance).")}this.#prevPosition=value.copy()}set rotationSpeed(value){if(typeof value!=="number"){throw new Error("rotationSpeed must be a number.")}this.#rotationSpeed=value}set radius(value){if(typeof value!=="number"){throw new Error("radius must be a number.")}this.#radius=value}set mass(value){if(typeof value!=="number"){throw new Error("mass must be a number.")}this.#mass=value}set bounciness(value){if(typeof value!=="number"){throw new Error("bounciness must be a number.")}this.#bounciness=value}set airFriction(value){if(typeof value!=="number"){throw new Error("airFriction must be a number.")}this.#airFriction=value}set surfaceFriction(value){if(typeof value!=="number"){throw new Error("surfaceFriction must be a number.")}this.#surfaceFriction=value}set locked(value){if(typeof value!=="boolean"){throw new Error("locked must be a boolean value.")}this.#locked=value}set collider(value){if(typeof value!=="boolean"){throw new Error("collider must be a boolean value.")}this.#collider=value}set parent(value){if(!(value instanceof PhysicsObject)&&value!==null){throw new Error("Parent must be an instance of PhysicsNode or null.")}this.#parent=value}set maxVelocityMagnitude(value){if(typeof value!=="number"){throw new Error("maxVelocityMagnitude must be a number.")}this.#maxVelocityMagnitude=value}}class PhysicsObject{#physicsSimulation;#name;#nodes;#connections;#solidShape;#referenceVector;#rotation;constructor(physicsSimulation,nodes,connections,name="PhysicsObject",solidShape){if(!physicsSimulation){throw new Error("A valid physics simulation instance is required.")}if(!Array.isArray(nodes)||nodes.some(node=>!(node instanceof PhysicsNode))){throw new Error("nodes should be an array of PhysicsNode instances.")}if(!Array.isArray(connections)||connections.some(conn=>!(conn instanceof PhysicsConnection))){throw new Error("connections should be an array of PhysicsConnection instances.")}if(typeof name!=="string"){throw new Error("name should be a string.")}if(typeof solidShape!=="boolean"){throw new Error("solidShape should be a boolean value.")}this.#physicsSimulation=physicsSimulation;this.#name=name;this.#nodes=nodes;this.#connections=connections;this.#solidShape=solidShape;this.#referenceVector=Vector.sub(this.#nodes[1].position,this.#nodes[0].position);this.#rotation=0;this.#nodes.forEach(node=>node.parent=this);this.#connections.forEach(connection=>connection.parent=this);this.#nodes.forEach(node=>this.#physicsSimulation.addPhysicsNode(node));this.#connections.forEach(connection=>this.#physicsSimulation.addPhysicsConnection(connection))}addForce(force){if(!(force instanceof Vector)){throw new Error("The force should be an instance of Vector.")}for(let node of this.#nodes){node.addForce(force)}}onCollision(other){}getWeightedPosition(){let totalMass=0;let weightedPosition=new Vector(0,0);for(let node of this.#nodes){totalMass+=node.mass;let weightedNodePosition=node.position.copy().mult(node.mass);weightedPosition.add(weightedNodePosition)}if(totalMass==0)return new Vector(0,0);return weightedPosition.div(totalMass)}getPosition(){let sumPosition=new Vector(0,0);for(let node of this.#nodes){sumPosition.add(node.position)}if(this.#nodes.length==0)return new Vector(0,0);return sumPosition.div(this.#nodes.length)}getRotation(){const currentVector=Vector.sub(this.#nodes[1].position,this.#nodes[0].position);return this.#computeRotation(this.#referenceVector,currentVector)}getMass(){let totalMass=0;for(let node of this.#nodes){totalMass+=node.mass}return totalMass}removeFromSimulation(){for(let node of this.#nodes){this.#physicsSimulation.removePhysicsNode(node)}for(let connection of this.#connections){this.#physicsSimulation.removePhysicsConnection(connection)}}#computeRotation(referenceVector,currentVector){let dotProduct=referenceVector.dot(currentVector);let magnitudeProduct=referenceVector.mag()*currentVector.mag();if(magnitudeProduct==0)return 0;let cosineTheta=dotProduct/magnitudeProduct;cosineTheta=Math.min(Math.max(cosineTheta,-1),1);let theta=Math.acos(cosineTheta);let rotationDirection=referenceVector.cross(currentVector);if(rotationDirection<0){theta=-theta}return theta*180/Math.PI}get name(){return this.#name}get nodes(){return this.#nodes}get connections(){return this.#connections}get solidShape(){return this.#solidShape}set name(value){if(typeof value!=="string"){throw new Error("Name must be a string.")}this.#name=value}set solidShape(value){if(typeof value!=="boolean"){throw new Error("solidShape must be a boolean.")}this.#solidShape=value}}class PhysicsRect extends PhysicsObject{constructor(physicsSimulation,position,width,height,rectName="PhysicsRect",radius=3,mass=1,bounciness=0,airFriction=.999,surfaceFriction=.75,collider=true,nodeName="PhysicsNode"){if(!physicsSimulation){throw new Error("A valid physics simulation instance is required.")}if(!(position instanceof Vector)){throw new Error("Position must be an instance of Vector.")}if(typeof width!=="number"||width<=0){throw new Error("Width must be a positive number.")}if(typeof height!=="number"||height<=0){throw new Error("Height must be a positive number.")}if(typeof radius!=="number"||radius<=0){throw new Error("Radius must be a positive number.")}if(typeof mass!=="number"||mass<=0){throw new Error("Mass must be a positive number.")}if(typeof bounciness!=="number"||bounciness<0){throw new Error("Bounciness must be a non-negative number.")}if(typeof airFriction!=="number"||airFriction<0||airFriction>1){throw new Error("AirFriction must be a number between 0 and 1.")}if(typeof surfaceFriction!=="number"||surfaceFriction<0||surfaceFriction>1){throw new Error("SurfaceFriction must be a number between 0 and 1.")}if(typeof collider!=="boolean"){throw new Error("Collider must be a boolean value.")}if(typeof rectName!=="string"||typeof nodeName!=="string"){throw new Error("Both rectName and nodeName should be string values.")}const halfWidth=width/2;const halfHeight=height/2;const topLeft=new PhysicsNode(new Vector(position.x-halfWidth,position.y-halfHeight),radius,mass,bounciness,airFriction,surfaceFriction,false,collider,nodeName);const topRight=new PhysicsNode(new Vector(position.x+halfWidth,position.y-halfHeight),radius,mass,bounciness,airFriction,surfaceFriction,false,collider,nodeName);const bottomLeft=new PhysicsNode(new Vector(position.x-halfWidth,position.y+halfHeight),radius,mass,bounciness,airFriction,surfaceFriction,false,collider,nodeName);const bottomRight=new PhysicsNode(new Vector(position.x+halfWidth,position.y+halfHeight),radius,mass,bounciness,airFriction,surfaceFriction,false,collider,nodeName);const nodes=[topLeft,topRight,bottomLeft,bottomRight];const topConnection=new PhysicsConnection(topLeft,topRight,width);const bottomConnection=new PhysicsConnection(bottomLeft,bottomRight,width);const leftConnection=new PhysicsConnection(topLeft,bottomLeft,height);const rightConnection=new PhysicsConnection(topRight,bottomRight,height);const diagonalConnectionTopDown=new PhysicsConnection(topLeft,bottomRight,Math.sqrt(width*width+height*height),false);const diagonalConnectionDownTop=new PhysicsConnection(topRight,bottomLeft,Math.sqrt(width*width+height*height),false);const connections=[topConnection,bottomConnection,leftConnection,rightConnection,diagonalConnectionTopDown,diagonalConnectionDownTop];super(physicsSimulation,nodes,connections,rectName,true)}}class PhysicsPolygon extends PhysicsObject{#outerRadius;#corners;constructor(physicsSimulation,position,outerRadius,corners,polygonName="PhysicsPolygon",nodeRadius=3,nodeMass=1,nodeBounciness=0,nodeAirFriction=.999,nodeSurfaceFriction=.75,collider=true,nodeName="PhysicsNode"){if(!physicsSimulation){throw new Error("A valid physics simulation instance is required.")}if(!(position instanceof Vector)){throw new Error("Position must be an instance of Vector.")}if(typeof outerRadius!=="number"||outerRadius<=0){throw new Error("outerRadius must be a positive number.")}if(typeof nodeRadius!=="number"||nodeRadius<=0){throw new Error("nodeRadius must be a positive number.")}if(typeof corners!=="number"||corners<3||corners>10){throw new Error("The number of corners must be a number between 3 and 10.")}if(typeof nodeMass!=="number"||nodeMass<=0){throw new Error("nodeMass must be a positive number.")}if(typeof nodeBounciness!=="number"||nodeBounciness<0){throw new Error("nodeBounciness must be a non-negative number.")}if(typeof nodeAirFriction!=="number"||nodeAirFriction<0||nodeAirFriction>1){throw new Error("nodeAirFriction must be a number between 0 and 1.")}if(typeof nodeSurfaceFriction!=="number"||nodeSurfaceFriction<0||nodeSurfaceFriction>1){throw new Error("nodeSurfaceFriction must be a number between 0 and 1.")}if(typeof collider!=="boolean"){throw new Error("collider must be a boolean value.")}if(typeof polygonName!=="string"||typeof nodeName!=="string"){throw new Error("Both polygonName and nodeName should be string values.")}const nodes=[];const connections=[];const angleIncrement=2*Math.PI/corners;for(let i=0;i<corners;i++){const x=position.x+outerRadius*Math.cos(i*angleIncrement);const y=position.y+outerRadius*Math.sin(i*angleIncrement);const node=new PhysicsNode(new Vector(x,y),nodeRadius,nodeMass,nodeBounciness,nodeAirFriction,nodeSurfaceFriction,false,collider,nodeName);nodes.push(node)}for(let i=0;i<corners;i++){for(let j=i+1;j<corners;j++){const startNode=nodes[i];const endNode=nodes[j];const connection=new PhysicsConnection(startNode,endNode,Vector.distance(startNode.position,endNode.position));if(j!==i+1&&j!==(i-1+corners)%corners){connection.collider=false}connections.push(connection)}}super(physicsSimulation,nodes,connections,polygonName,true);this.#outerRadius=outerRadius;this.#corners=corners}get outerRadius(){return this.#outerRadius}get corners(){return this.#corners}}class PhysicsRope extends PhysicsObject{constructor(physicsSimulation,startPosition,endPosition,nodeCount,stiffness=1,nodeRadius=3,nodeMass=1,collider=true,nodeName="PhysicsNode"){if(!physicsSimulation){throw new Error("A valid physics simulation instance is required.")}if(!(startPosition instanceof Vector)||!(endPosition instanceof Vector)){throw new Error("Start and end positions should be instances of Vector.")}if(typeof nodeCount!=="number"||nodeCount<2){throw new Error("Node count should be a number greater than or equal to 2.")}if(typeof stiffness!=="number"||stiffness<.1||stiffness>10){throw new Error("Node stiffness should be a number greater or equal to 0.1 and smaller than  or equal to 10.")}if(typeof nodeRadius!=="number"||nodeRadius<=0){throw new Error("Node radius should be a positive number.")}if(typeof nodeMass!=="number"||nodeMass<=0){throw new Error("Node mass should be a positive number.")}if(typeof collider!=="boolean"){throw new Error("Collider should be a boolean value.")}if(typeof nodeName!=="string"){throw new Error("Node name should be a string.")}const nodes=[];const connections=[];const totalDistance=Vector.sub(endPosition,startPosition);const nodeSpacing=totalDistance.div(nodeCount-1);for(let i=0;i<nodeCount;i++){const position=new Vector(startPosition.x+i*nodeSpacing.x,startPosition.y+i*nodeSpacing.y);const node=new PhysicsNode(position,nodeRadius,nodeMass,0,.999,.75,false,collider,nodeName);nodes.push(node);if(i!==0){const connection=new PhysicsConnection(nodes[i-1],node,Vector.distance(nodes[i-1].position,node.position)*stiffness);connection.collider=false;connections.push(connection)}}super(physicsSimulation,nodes,connections,"PhysicsRope",false)}}class Random{static seededRandom(seed){if(typeof seed!=="number"){throw new Error("Invalid seed: Expected a number.")}let t=seed+=1831565813;t=Math.imul(t^t>>>15,t|1);t^=t+Math.imul(t^t>>>7,t|61);return((t^t>>>14)>>>0)/4294967296}static seededRandomBetween(min,max,seed){if(typeof min!=="number"||typeof max!=="number"||typeof seed!=="number"){throw new Error("Invalid arguments: Expected numbers for min, max, and seed.")}return this.seededRandom(seed)*(max-min)+min}static randomBetween(min,max){if(typeof min!=="number"||typeof max!=="number"){throw new Error("Invalid arguments: Expected numbers for min and max.")}return Math.random()*(max-min)+min}}class PerlinNoise{#repeatVal;#seed;constructor(seed=0,repeatVal=256){if(typeof seed!=="number"){throw new Error("Invalid seed: Expected a number.")}if(typeof repeatVal!=="number"||repeatVal<=0){throw new Error("Invalid repeatVal: Expected a positive number.")}this.#repeatVal=repeatVal;this.#seed=seed}getValue(x,y){if(typeof x!=="number",typeof y!=="number"){throw new Error("Invalid arguments: x and y are expected to be numbers.")}x=x-~~(x/this.#repeatVal)*this.#repeatVal;y=y-~~(y/this.#repeatVal)*this.#repeatVal;const pos1=new Vector(~~x,~~y);const pos2=new Vector(~~x+1,~~y);const pos3=new Vector(~~x,~~y+1);const pos4=new Vector(~~x+1,~~y+1);const seed1=this.#seed+pos1.y%this.#repeatVal*this.#repeatVal+pos1.x%this.#repeatVal;const seed2=this.#seed+pos2.y%this.#repeatVal*this.#repeatVal+pos2.x%this.#repeatVal;const seed3=this.#seed+pos3.y%this.#repeatVal*this.#repeatVal+pos3.x%this.#repeatVal;const seed4=this.#seed+pos4.y%this.#repeatVal*this.#repeatVal+pos4.x%this.#repeatVal;const vec1=new Vector(1-Random.seededRandom(seed1)*2,1-Random.seededRandom(seed1+1)*2);const vec2=new Vector(1-Random.seededRandom(seed2)*2,1-Random.seededRandom(seed2+1)*2);const vec3=new Vector(1-Random.seededRandom(seed3)*2,1-Random.seededRandom(seed3+1)*2);const vec4=new Vector(1-Random.seededRandom(seed4)*2,1-Random.seededRandom(seed4+1)*2);const to1=new Vector(x,y).sub(pos1);const to2=new Vector(x,y).sub(pos2);const to3=new Vector(x,y).sub(pos3);const to4=new Vector(x,y).sub(pos4);const u=this.#fade(x-~~x);const v=this.#fade(y-~~y);const topVal=GameMath.lerp(Vector.dot(vec1,to1),Vector.dot(vec2,to2),u);const bottomVal=GameMath.lerp(Vector.dot(vec3,to3),Vector.dot(vec4,to4),u);return GameMath.lerp(topVal,bottomVal,v)}getFBMValue(x,y,octaves=4,persistence=.5){if(typeof x!=="number"||typeof y!=="number"||typeof octaves!=="number"||typeof persistence!=="number"){throw new Error("Invalid arguments: Expected numbers for x, y, octaves, and persistence.")}if(octaves<=0){throw new Error("Invalid octaves: Expected a positive number.")}if(persistence<0||persistence>1){throw new Error("Invalid persistence: Expected a value between 0 and 1.")}let total=0;let frequency=1;let amplitude=1;let maxValue=0;for(let i=0;i<octaves;i++){total+=this.getValue(x*frequency,y*frequency)*amplitude;maxValue+=amplitude;amplitude*=persistence;frequency*=2}return total/maxValue}#fade(t){if(typeof t!=="number"){throw new Error("Invalid argument: Expected a number.")}return((6*t-15)*t+10)*t*t*t}}class VoronoiNoise{#cellCount;#repeatVal;#seed;#grid;#cellSize;constructor(cellCount,seed=0,repeatVal=256){if(typeof cellCount!=="number"||cellCount<=0){throw new Error("Invalid cellCount: Expected a positive number.")}if(typeof seed!=="number"){throw new Error("Invalid seed: Expected a number.")}if(typeof repeatVal!=="number"||repeatVal<=0){throw new Error("Invalid repeatVal: Expected a positive number.")}this.#cellCount=cellCount;this.#repeatVal=repeatVal;this.#seed=seed;this.#cellSize=this.#repeatVal/this.#cellCount;this.#initializeGrid()}#initializeGrid(){this.#grid=new Array(this.#cellCount);let seed=this.#seed;for(let y=0;y<this.#cellCount;y++){this.#grid[y]=new Array(this.#cellCount);for(let x=0;x<this.#cellCount;x++){if(x===this.#cellCount-1&&y!==this.#cellCount-1){this.#grid[y][x]=new Vector(0,this.#grid[y][0].y)}else if(y===this.#cellCount-1&&x!==this.#cellCount-1){this.#grid[y][x]=new Vector(this.#grid[0][x].x,0)}else if(x===this.#cellCount-1&&y===this.#cellCount-1){this.#grid[y][x]=new Vector(0,0)}else{this.#grid[y][x]=new Vector(x*this.#cellSize+Random.seededRandom(seed)*this.#cellSize,y*this.#cellSize+Random.seededRandom(seed)*this.#cellSize)}seed+=Random.seededRandomBetween(1,10,seed)}}}#getTilingDistance(p1,p2){const dx=Math.abs(p2.x-p1.x);const dy=Math.abs(p2.y-p1.y);const tdx=this.#repeatVal-dx;const tdy=this.#repeatVal-dy;const minDx=Math.min(dx,tdx);const minDy=Math.min(dy,tdy);return Math.sqrt(minDx*minDx+minDy*minDy)}getValue(x,y){if(typeof x!=="number"||typeof y!=="number"){throw new Error("Invalid arguments: Expected numbers for x and y.")}const cellX=Math.floor(x/this.#cellSize);const cellY=Math.floor(y/this.#cellSize);let minDistance=Infinity;for(let offsetY=-1;offsetY<=1;offsetY++){for(let offsetX=-1;offsetX<=1;offsetX++){const curCellX=(cellX+offsetX+this.#grid[0].length)%this.#grid[0].length;const curCellY=(cellY+offsetY+this.#grid.length)%this.#grid.length;const point=this.#grid[curCellY][curCellX];const distance=this.#getTilingDistance(point,new Vector(x,y));if(distance<minDistance){minDistance=distance}}}return minDistance}}class CellularAutomata{#width;#height;#map=[];#noiseMap;constructor(width,height){if(typeof width!=="number"||width<=0){throw new Error("Invalid width: Expected a positive number.")}if(typeof height!=="number"||height<=0){throw new Error("Invalid height: Expected a positive number.")}this.#width=width;this.#height=height}getCave(noiseDensity=.4,interations=10,seed=0){if(typeof noiseDensity!=="number"||noiseDensity<0||noiseDensity>1){throw new Error("Invalid noiseDensity: Expected a number between 0 and 1.")}if(typeof interations!=="number"||interations<=0){throw new Error("Invalid interations: Expected a positive number.")}if(typeof seed!=="number"){throw new Error("Invalid seed: Expected a number.")}this.#noiseMap=this.#getNoiseMap(noiseDensity,seed);for(let i=0;i<interations;i++){this.#iterate();this.#updateNoiseMap()}return this.#map}#iterate(){for(let y=0;y<this.#height;y++){this.#map[y]=[];for(let x=0;x<this.#width;x++){this.#map[y][x]=this.#getCellValue(x,y)}}}#getCellValue(x,y){let counter=0;for(let j=y-1;j<=y+1;j++){for(let i=x-1;i<=x+1;i++){if(i==x&&j==y)continue;if(i<0||j<0||i>=this.#width||j>=this.#height){counter++}else{counter=this.#noiseMap[j][i]===0?counter+1:counter}}}return counter>4?0:1}#getNoiseMap(noiseDensity,seed){let result=[];for(let y=0;y<this.#height;y++){result[y]=[];for(let x=0;x<this.#width;x++){result[y][x]=Random.seededRandom(seed)<noiseDensity?0:1;seed+=Random.seededRandomBetween(1,10,seed)}}return result}#updateNoiseMap(){for(let y=0;y<this.#height;y++){for(let x=0;x<this.#width;x++){this.#noiseMap[y][x]=this.#map[y][x]}}}get width(){return this.#width}get height(){return this.#height}}class Ray{constructor(pos,dir,length,cellSize,map){if(!Array.isArray(map)||!Array.isArray(map[0])){throw new Error("Invalid map: Expected a 2D array.")}this.position=pos;this.direction=dir;this.length=length;this.cellSize=cellSize;this.map=map;this.hit=null;this.hitSide=0}updateData(pos,dir){this.position=pos;this.direction=dir}cast(map){let xCollision=false;let yCollision=false;let stepX=0;let stepY=0;let dx=this.cellSize-this.position.x%this.cellSize;let dy=this.cellSize-this.position.y%this.cellSize;let result=null;let resultLength=this.length;let counter=0;let xFactor,yFactor;let xTransparentHit=false;let yTransparentHit=false;if(this.direction.x<0){xFactor=-1;dx-=this.cellSize}else{xFactor=1}if(this.direction.y<0){yFactor=-1;dy-=this.cellSize}else{yFactor=1}while((!xCollision||!yCollision)&&stepX<=this.length||stepY<=this.length){counter++;if(counter>=(map[0].length+map.length)*2){console.warn("DDA ran too long! Reduce the lengths of the rays.");break}if(stepX<stepY){if(this.direction.x==0){stepX=this.length}else{let moveX=dx;let moveY=this.direction.y/this.direction.x*dx;stepX=Math.sqrt(Math.pow(moveX,2)+Math.pow(moveY,2));dx+=this.cellSize*xFactor;let x=(this.position.x+moveX+xFactor)/this.cellSize;let y=(this.position.y+moveY)/this.cellSize;if(x<map[0].length&&y<map.length&&x>0&&y>0){if(map[Math.floor(y)][Math.floor(x)]<0&&!xTransparentHit){xTransparentHit=true;dx-=this.cellSize*xFactor/2}else{xCollision=map[Math.floor(y)][Math.floor(x)]!=0;result=xCollision&&stepX<resultLength?new Vector(x*this.cellSize,y*this.cellSize):result;this.hitSide=xCollision&&stepX<resultLength?1:this.hitSide;resultLength=xCollision&&stepX<resultLength?stepX:resultLength}}}}else{if(this.direction.y==0){stepY=this.length}else{let moveX=this.direction.x/this.direction.y*dy;let moveY=dy;stepY=Math.sqrt(Math.pow(moveX,2)+Math.pow(moveY,2));dy+=this.cellSize*yFactor;let x=(this.position.x+moveX)/this.cellSize;let y=(this.position.y+moveY+yFactor)/this.cellSize;if(x<map[0].length&&y<map.length&&x>0&&y>0){if(map[Math.floor(y)][Math.floor(x)]<0&&!yTransparentHit){yTransparentHit=true;dy-=this.cellSize*yFactor/2}else{yCollision=map[Math.floor(y)][Math.floor(x)]!=0;result=yCollision&&stepY<resultLength?new Vector(x*this.cellSize,y*this.cellSize):result;this.hitSide=yCollision&&stepY<resultLength?2:this.hitSide;resultLength=yCollision&&stepY<resultLength?stepY:resultLength}}}}}return result}}class RaycasterCamera extends Camera{#map;#floorMap;#ceilingMap;#wallTextures;#floorTextures;#floorTexture;#ceilingTextures;#ceilingTexture;#lightTravelDist;#maxLightVal;#rayLength;#position;#lookOffsetZ;#rotation;#velocity;#friction;#fov;#blockSize;#playerHeight;#distFromPlayerToProjectionPlane;#camWallGapFactor;#rays;#cellSize;constructor(gameWidth,gameHeight,canvasWidth,canvasHeight,canvasName,map,floorMap,ceilingMap,wallTextures,floorTextures,ceilingTextures,position,rotation=0,friction=5,fov=60,blockSize=32){if(!Array.isArray(wallTextures)||!wallTextures.every(image=>image instanceof Image)){throw new Error("Invalid images: Expected an array of Image objects.")}if(!Array.isArray(map)||!Array.isArray(map[0])||!map.every(row=>row.every(Number.isInteger))){throw new Error("Invalid map: Expected a 2D array of integers.")}if(map.some(row=>row.length!==map[0].length)){throw new Error("Invalid map: Every row in the map has to have the same number of indices.")}if(map.every(row=>row.every(index=>index>=wallTextures.length))){throw new Error("Invalid map: One of the indecies is higher than the number of images provided.")}if(!(position instanceof Vector)){throw new Error("Invalid position: Expected a Vector object.")}if(typeof rotation!=="number"){throw new Error("Invalid rotation: Expected a number.")}const adjustedGameHeight=~~gameHeight%2==0?~~gameHeight:~~gameHeight+1;super(gameWidth,adjustedGameHeight,canvasWidth,canvasHeight,canvasName);this.#map=map;this.#floorMap=floorMap;this.#ceilingMap=ceilingMap;this.#wallTextures=wallTextures;this.#floorTextures=floorTextures;this.#ceilingTextures=ceilingTextures;this.#lightTravelDist=blockSize*10;this.#maxLightVal=1;this.#rayLength=blockSize*11;this.#position=position;this.#rotation=rotation;this.#lookOffsetZ=0;this.#velocity=new Vector(0,0);this.#friction=GameMath.clamp(friction,0,10);this.#fov=fov;this.#blockSize=blockSize;this.#playerHeight=~~(blockSize/2);this.#distFromPlayerToProjectionPlane=this.gameWidth/2/Math.tan(fov/2*Math.PI/180);this.#camWallGapFactor=2;this.#rays=[];this.initializeRays()}initializeRays(){const totalRays=this.gameWidth;const angleBetweenRays=this.#fov/totalRays;let currentAngle=-(this.#fov/2)+this.#rotation;for(let i=0;i<totalRays;i++){currentAngle+=angleBetweenRays;const dirX=Math.cos(GameMath.degreesToRadians(currentAngle));const dirY=Math.sin(GameMath.degreesToRadians(currentAngle));const ray=new Ray(this.#position,new Vector(dirX,dirY),this.#rayLength,this.#blockSize,this.#map);this.#rays.push(ray)}}updateRays(){const deltaTime=this.getDeltaTime();const totalRays=this.#rays.length;const angleBetweenRays=this.#fov/totalRays;let currentAngle=-(this.#fov/2)+this.#rotation;for(let i=0;i<totalRays;i++){currentAngle+=angleBetweenRays;const dirX=Math.cos(GameMath.degreesToRadians(currentAngle));const dirY=Math.sin(GameMath.degreesToRadians(currentAngle));this.#rays[i].updateData(this.#position,new Vector(dirX,dirY))}const reductionFactor=Math.exp(-this.#friction*deltaTime);this.#velocity.mult(reductionFactor);const dirX=this.#velocity.x>0?1:-1;const dirY=this.#velocity.y>0?1:-1;const gapFactor=this.#camWallGapFactor;let moveFactorX=this.#map[~~(this.#position.y/this.#blockSize)][~~((this.#position.x+this.#velocity.x*deltaTime+gapFactor*dirX)/this.#blockSize)]==0?1:0;moveFactorX*=this.#position.x+this.#velocity.x*deltaTime+gapFactor>=(this.#map[0].length-1)*this.#blockSize||this.#position.x+this.#velocity.x*deltaTime-gapFactor<=0?0:1;let moveFactorY=this.#map[~~((this.#position.y+this.#velocity.y*deltaTime+gapFactor*dirY)/this.#blockSize)][~~(this.#position.x/this.#blockSize)]==0?1:0;moveFactorY*=this.#position.y+this.#velocity.y*deltaTime+gapFactor>=(this.#map.length-1)*this.#blockSize||this.#position.y+this.#velocity.y*deltaTime-gapFactor<=0?0:1;this.#velocity.mult(new Vector(moveFactorX,moveFactorY));this.#position.add(this.#velocity.copy().mult(deltaTime))}move(speed){const deltaTime=this.getDeltaTime();const force=new Vector(Math.cos(GameMath.degreesToRadians(this.#rotation)),Math.sin(GameMath.degreesToRadians(this.#rotation)));force.mult(speed*deltaTime);this.#velocity.add(force)}rotate(speed){const deltaTime=this.getDeltaTime();this.#rotation+=speed*deltaTime}strafe(speed){const deltaTime=this.getDeltaTime();const force=new Vector(Math.cos(GameMath.degreesToRadians(this.#rotation+90)),Math.sin(GameMath.degreesToRadians(this.#rotation+90)));force.mult(speed*deltaTime);this.#velocity.add(force)}tilt(speed){const deltaTime=this.getDeltaTime();const maxTiltValue=this.gameHeight/2;this.#lookOffsetZ=GameMath.clamp(this.#lookOffsetZ+speed*deltaTime,-maxTiltValue,maxTiltValue)}render3D(){this.updateRays();this.#renderFloorAndCeiling();this.#renderWalls()}#renderWalls(){for(let column=0;column<this.#rays.length;column++){const hitPosition=this.#rays[column].cast(this.#map);if(hitPosition){let distHit=Math.sqrt(Math.pow(hitPosition.x-this.#position.x,2)+Math.pow(hitPosition.y-this.#position.y,2));let rayAngle=this.#rotation+(column/this.gameWidth-.5)*this.#fov;rayAngle=GameMath.degreesToRadians(rayAngle);distHit=distHit*Math.cos(rayAngle-GameMath.degreesToRadians(this.#rotation));const sliceHeight=~~(this.#blockSize/distHit*this.#distFromPlayerToProjectionPlane);let drawHeight=sliceHeight;let startY=this.gameHeight/2-drawHeight/2;startY+=this.#lookOffsetZ;const adjustedHit=Vector.mult(hitPosition,1e-5);const textureIndex=this.#map[~~(adjustedHit.y/this.#blockSize)][~~(adjustedHit.x/this.#blockSize)];const texture=this.#wallTextures[textureIndex-1];if(!texture){continue}let textureX;if(this.#rays[column].hitSide===2){textureX=hitPosition.x%this.#blockSize}else{textureX=hitPosition.y%this.#blockSize}textureX=~~(textureX*(texture.width/this.#blockSize));let textureY=0;let textureHeight=texture.height;this.ctx.drawImage(texture,textureX,textureY,1,textureHeight,column,startY,1,drawHeight);const lightingVal=GameMath.remap(distHit,0,this.#lightTravelDist,1-this.#maxLightVal,1);const shadeFactor=this.#rays[column].hitSide==2?0:this.#maxLightVal*.3;this.ctx.fillStyle=`rgba(0, 0, 0, ${lightingVal+shadeFactor})`;this.ctx.fillRect(column,startY-1,1,drawHeight+2)}}}#renderFloorAndCeiling(){const width=this.gameWidth;const adjustedHight=~~(this.gameHeight+Math.abs(this.#lookOffsetZ)*2);const height=adjustedHight%2==0?adjustedHight:adjustedHight+1;const halfHeight=height/2;const playerHeight=this.#playerHeight;let imageData=this.ctx.createImageData(width,height);let interpolationSkip;for(let y=0;y<=halfHeight;y++){interpolationSkip=10;const adjustedY=this.#lookOffsetZ<0?y:y;for(let x=0;x<this.gameWidth-1;x+=interpolationSkip){let distToFloorPoint=Math.abs(this.#distFromPlayerToProjectionPlane*(this.#playerHeight/(adjustedY-height/2)));distToFloorPoint/=Math.cos((this.#fov/2-x*(this.#fov/this.gameWidth))*Math.PI/180);let textPixel=this.#getFloorCeilingTextureIndex(x,distToFloorPoint);let floorTexture=this.#floorTexture;let ceilingTexture=this.#ceilingTexture;if(x+interpolationSkip>=this.gameWidth){interpolationSkip=1}const nextIndex=x+interpolationSkip;let textPixelFuture=this.#getFloorCeilingTextureIndex(nextIndex,distToFloorPoint);if(textPixel==null||textPixelFuture==null)continue;const mapPoint=new Vector(~~(textPixel.x/this.#blockSize),~~(textPixel.y/this.#blockSize));const mapPointFuture=new Vector(~~(textPixelFuture.x/this.#blockSize),~~(textPixelFuture.y/this.#blockSize));const imageDataIndex=(x+(height-adjustedY)*width)*4;const imageDataIndexCeiling=(x+adjustedY*width)*4;const colorVal=GameMath.remap(distToFloorPoint,0,this.#lightTravelDist,this.#maxLightVal,0);for(let i=0;i<interpolationSkip;i++){if(mapPoint.x!=mapPointFuture.x||mapPoint.y!=mapPointFuture.y){let accuratePixel=this.#getFloorCeilingTextureIndex(x+i,distToFloorPoint);floorTexture=this.#floorTexture;ceilingTexture=this.#ceilingTexture;if(accuratePixel==null)continue;const floorPixel=(accuratePixel.y*floorTexture.width+accuratePixel.x)*4;const ceilingPixel=(accuratePixel.y*ceilingTexture.width+accuratePixel.x)*4;const index=imageDataIndex+i*4;imageData.data[index]=floorTexture.data[floorPixel]*colorVal;imageData.data[index+1]=floorTexture.data[floorPixel+1]*colorVal;imageData.data[index+2]=floorTexture.data[floorPixel+2]*colorVal;imageData.data[index+3]=floorTexture.data[floorPixel+3]*colorVal;const ceilingIndex=imageDataIndexCeiling+i*4;imageData.data[ceilingIndex]=ceilingTexture.data[ceilingPixel]*colorVal;imageData.data[ceilingIndex+1]=ceilingTexture.data[ceilingPixel+1]*colorVal;imageData.data[ceilingIndex+2]=ceilingTexture.data[ceilingPixel+2]*colorVal;imageData.data[ceilingIndex+3]=ceilingTexture.data[ceilingPixel+3]*colorVal;continue}const interpolatedX=~~GameMath.lerp(textPixel.x,textPixelFuture.x,i/interpolationSkip);const interpolatedY=~~GameMath.lerp(textPixel.y,textPixelFuture.y,i/interpolationSkip);const floorPixel=(interpolatedY*floorTexture.width+interpolatedX)*4;const ceilingPixel=(interpolatedY*ceilingTexture.width+interpolatedX)*4;const index=imageDataIndex+i*4;imageData.data[index]=floorTexture.data[floorPixel]*colorVal;imageData.data[index+1]=floorTexture.data[floorPixel+1]*colorVal;imageData.data[index+2]=floorTexture.data[floorPixel+2]*colorVal;imageData.data[index+3]=floorTexture.data[floorPixel+3]*colorVal;const ceilingIndex=imageDataIndexCeiling+i*4;imageData.data[ceilingIndex]=ceilingTexture.data[ceilingPixel]*colorVal;imageData.data[ceilingIndex+1]=ceilingTexture.data[ceilingPixel+1]*colorVal;imageData.data[ceilingIndex+2]=ceilingTexture.data[ceilingPixel+2]*colorVal;imageData.data[ceilingIndex+3]=ceilingTexture.data[ceilingPixel+3]*colorVal}}}if(this.#lookOffsetZ<0){this.ctx.putImageData(imageData,0,0+this.#lookOffsetZ*2)}else{this.ctx.putImageData(imageData,0,0)}}#getFloorCeilingTextureIndex(x,distToFloorPoint){if(distToFloorPoint>=this.#lightTravelDist)return null;let floorPoint=this.#position.copy();let rayDirection=this.#rays[x].direction.copy();rayDirection.normalize();rayDirection.mult(distToFloorPoint);floorPoint.add(rayDirection);let pointMapX=Math.ceil(floorPoint.x/this.#blockSize)-1;let pointMapY=Math.ceil(floorPoint.y/this.#blockSize)-1;if(pointMapX>=0&&pointMapX<this.#floorMap[0].length&&pointMapY>=0&&pointMapY<this.#floorMap.length){const floorTextureIndex=this.#floorMap[pointMapY][pointMapX];this.#floorTexture=this.#floorTextures[floorTextureIndex];const ceilingTextureIndex=this.#ceilingMap[pointMapY][pointMapX];this.#ceilingTexture=this.#ceilingTextures[ceilingTextureIndex];let textureX=Math.floor(floorPoint.x%this.#blockSize*(this.#floorTexture.width/this.#blockSize));let textureY=Math.floor(floorPoint.y%this.#blockSize*(this.#floorTexture.height/this.#blockSize));return new Vector(textureX,textureY)}else{return null}}render2D(){this.updateRays();const blockWidth=this.gameWidth/this.#map[0].length;const blockHeight=this.gameHeight/this.#map.length;const screenToWorldRatio=new Vector(this.gameWidth/(this.#map[0].length*this.#blockSize),this.gameHeight/(this.#map.length*this.#blockSize));const screenPosition=this.#position.copy().mult(screenToWorldRatio);this.drawRect(new Vector(this.gameWidth/2,this.gameHeight/2),this.gameWidth,this.gameHeight,new Color(255,255,255,255));for(let y=0;y<this.#map.length;y++){for(let x=0;x<this.#map[y].length;x++){const block=this.#map[y][x];if(block!=0){const blockImage=this.images[block-1];const renderX=x*blockWidth;const renderY=y*blockHeight;this.ctx.drawImage(blockImage,renderX,renderY,blockWidth,blockHeight)}}}for(let y=0;y<this.#map.length;y++)this.drawLine(new Vector(0,y*(this.gameHeight/this.#map.length)),new Vector(this.gameWidth,y*(this.gameHeight/this.#map.length)),new Color(0,0,0,255),3);for(let x=0;x<this.#map[0].length;x++)this.drawLine(new Vector(x*(this.gameWidth/this.#map[0].length),0),new Vector(x*(this.gameWidth/this.#map[0].length),this.gameHeight),new Color(0,0,0,255),3);this.#rays.forEach(ray=>{const hit=ray.cast(this.#map);if(hit){hit.mult(screenToWorldRatio);this.drawLine(screenPosition,hit)}else{const rayEnd=this.#position.copy().add(ray.direction.mult(ray.length));rayEnd.mult(screenToWorldRatio);this.drawLine(screenPosition,rayEnd)}});const radX=this.gameWidth/this.#map[0].length*.3;const radY=this.gameHeight/this.#map.length*.3;this.drawEllipse(screenPosition,radX,radY)}renderMinimap(position,sizeFactor,colorFloor,colorWall){}setTile(x,y,value){if(typeof x!=="number"||x<1||x!==Math.floor(x)){throw new Error("Invalid x-coordinate: Expected a whole number greater than or equal to 1.")}if(typeof y!=="number"||y<1||y!==Math.floor(y)){throw new Error("Invalid y-coordinate: Expected a whole number greater than or equal to 1.")}if(typeof value!=="number"||value!==Math.floor(value)){throw new Error("Invalid tile value: Expected a whole number.")}this.#map[~~y][~~x]=~~value}get map(){return this.#map}get images(){return this.#wallTextures}set map(newMap){if(!Array.isArray(newMap)||!Array.isArray(newMap[0])||!newMap.every(row=>row.every(Number.isInteger))){throw new Error("Invalid map: Expected a 2D array of integers.")}this.#map=newMap}set images(newImages){if(!Array.isArray(newImages)||!newImages.every(image=>image instanceof Image)){throw new Error("Invalid images: Expected an array of Image objects.")}this.#wallTextures=newImages}}class SpatialGrid{#width;#height;#cellSize;#columns;#rows;#grid;constructor(cellSize,width,height){if(typeof cellSize!=="number"||typeof width!=="number"||typeof height!=="number"){throw new Error("cellSize, width, and height must be numbers.")}if(cellSize<=0||width<=0||height<=0){throw new Error("cellSize, width, and height must be positive values.")}this.#width=width;this.#height=height;this.#cellSize=cellSize;this.#columns=Math.ceil(width/cellSize)+1;this.#rows=Math.ceil(height/cellSize)+1;this.#grid=Array.from({length:this.#rows},()=>Array.from({length:this.#columns},()=>[]))}insert(node){if(!(node instanceof PhysicsNode)||!(node.position instanceof Vector)){throw new Error("Invalid node. The node should be an instance of PhysicsNode and its position property should be an instance of Vector.")}const col=GameMath.clamp(~~(node.position.x/this.#cellSize),0,~~(this.#width/this.#cellSize));const row=GameMath.clamp(~~(node.position.y/this.#cellSize),0,~~(this.#height/this.#cellSize));try{this.#grid[row][col].push(node)}catch(error){console.warn("SpacialGrid error: "+row+", "+col+".")}}getNearby(node){if(!(node instanceof PhysicsNode)||!(node.position instanceof Vector)){throw new Error("Invalid node. The node should be an instance of PhysicsNode and its position property should be an instance of Vector.")}const col=Math.floor(node.position.x/this.#cellSize);const row=Math.floor(node.position.y/this.#cellSize);let nearbyNodes=[];for(let i=-1;i<=1;i++){for(let j=-1;j<=1;j++){const newRow=row+i;const newCol=col+j;if(newRow>=0&&newRow<this.#rows&&newCol>=0&&newCol<this.#columns){nearbyNodes=nearbyNodes.concat(this.#grid[newRow][newCol])}}}return nearbyNodes}getNodesForConnection(startNode,endNode){if(!(startNode instanceof PhysicsNode)||!(startNode.position instanceof Vector)){throw new Error("startNode should be an instance of PhysicsNode and its position should be an instance of Vector.")}if(!(endNode instanceof PhysicsNode)||!(endNode.position instanceof Vector)){throw new Error("endNode should be an instance of PhysicsNode and its position should be an instance of Vector.")}const cells=this.#getCellsForConnection(startNode,endNode);let nodes=[];for(let cell of cells){for(let i=-1;i<=1;i++){for(let j=-1;j<=1;j++){const newRow=cell.row+i;const newCol=cell.col+j;if(newRow>=0&&newRow<this.#rows&&newCol>=0&&newCol<this.#columns){nodes=nodes.concat(this.#grid[newRow][newCol])}}}}nodes=[...new Set(nodes)];return nodes}#getCellsForConnection(startNode,endNode){if(!(startNode instanceof PhysicsNode)||!(startNode.position instanceof Vector)){throw new Error("startNode should be an instance of PhysicsNode and its position should be an instance of Vector.")}if(!(endNode instanceof PhysicsNode)||!(endNode.position instanceof Vector)){throw new Error("endNode should be an instance of PhysicsNode and its position should be an instance of Vector.")}const cells=[];let x0=Math.floor(startNode.position.x/this.#cellSize);let y0=Math.floor(startNode.position.y/this.#cellSize);const x1=Math.floor(endNode.position.x/this.#cellSize);const y1=Math.floor(endNode.position.y/this.#cellSize);const dx=Math.abs(x1-x0);const dy=Math.abs(y1-y0);const sx=x0<x1?1:-1;const sy=y0<y1?1:-1;let err=dx-dy;let counter=0;while(true){cells.push({col:x0,row:y0});if(x0===x1&&y0===y1)break;const e2=2*err;if(e2>-dy){err-=dy;x0+=sx}if(e2<dx){err+=dx;y0+=sy}counter++;if(counter>1e3){console.error("Loop running for too long!");break}}return cells}clear(){for(let i=0;i<this.#rows;i++){for(let j=0;j<this.#columns;j++){this.#grid[i][j]=[]}}}}class TileCamera extends Camera{#map;#lights;#images;#zoomValue=1;#zoomTarget=new Vector(this.gameWidth/2,this.gameHeight/2);#tileEnglargment;constructor(gameWidth,gameHeight,canvasWidth,canvasHeight,canvasName,map,images,lights=[new Light(0,0,100,1,.5)],tileEnlargment=0){super(gameWidth,gameHeight,canvasWidth,canvasHeight,canvasName);if(!Array.isArray(map)||!Array.isArray(map[0])||!map.every(row=>row.every(Number.isInteger))){throw new Error("Invalid map: Expected a 2D array of integers.")}if(map.some(row=>row.length!==map[0].length)){throw new Error("Invalid map: Every row in the map has to have the same number of indices.")}if(map.every(row=>row.every(index=>index>=images.length))){throw new Error("Invalid map: One of the indecies is higher than the number of images provided.")}this.#map=map;if(!Array.isArray(images)||!images.every(image=>image instanceof Image)){throw new Error("Invalid images: Expected an array of Image objects.")}this.#images=images;if(!Array.isArray(lights)||!lights.every(light=>light instanceof Light)){throw new Error("Invalid lights: Expected an array of Light instances.")}this.#lights=lights;if(typeof tileEnlargment!=="number"||tileEnlargment<0){throw new Error("Invalid tileEnlargment value: Expected a number bigger or equal than 0.")}this.#tileEnglargment=tileEnlargment}render(){const tileWidth=this.gameWidth/this.#map[0].length*this.#zoomValue;const tileHeight=this.gameHeight/this.#map.length*this.#zoomValue;const offsetX=this.#zoomTarget.x*(1-this.#zoomValue);const offsetY=this.#zoomTarget.y*(1-this.#zoomValue);for(let y=0;y<this.#map.length;y++){for(let x=0;x<this.#map[y].length;x++){const tileIndex=this.#map[y][x];const tileImage=this.images[tileIndex];const renderX=x*tileWidth+offsetX;const renderY=y*tileHeight+offsetY;this.ctx.drawImage(tileImage,renderX,renderY,tileWidth+this.#tileEnglargment,tileHeight+this.#tileEnglargment)}}}renderLighting(){const lightCanvas=document.createElement("canvas");lightCanvas.width=this.gameWidth;lightCanvas.height=this.gameHeight;const lightCtx=lightCanvas.getContext("2d");lightCtx.fillStyle="black";lightCtx.fillRect(0,0,this.gameWidth,this.gameHeight);lightCtx.globalCompositeOperation="xor";for(const light of this.lights){const gradient=lightCtx.createRadialGradient(light.x,light.y,0,light.x,light.y,light.dist);gradient.addColorStop(0,`rgba(255, 255, 255, ${light.maxBrightness})`);gradient.addColorStop(light.gradientValue,`rgba(255, 255, 255, ${light.maxBrightness/2})`);gradient.addColorStop(1,"rgba(255, 255, 255, 0)");lightCtx.fillStyle=gradient;lightCtx.beginPath();lightCtx.arc(light.x,light.y,light.dist,0,2*Math.PI);lightCtx.fill()}this.ctx.globalCompositeOperation="multiply";this.ctx.drawImage(lightCanvas,0,0,this.gameWidth,this.gameHeight);this.ctx.globalCompositeOperation="source-over"}zoom(zoomValue,targetX,targetY){if(typeof zoomValue!=="number"||zoomValue<1){throw new Error("Invalid zoom value: Expected a number bigger or equal than 1.")}this.#zoomValue=zoomValue;this.#zoomTarget=new Vector(targetX,targetY)}setTile(x,y,value){if(typeof x!=="number"||x<1||x!==Math.floor(x)){throw new Error("Invalid x-coordinate: Expected a whole number greater than or equal to 1.")}if(typeof y!=="number"||y<1||y!==Math.floor(y)){throw new Error("Invalid y-coordinate: Expected a whole number greater than or equal to 1.")}if(typeof value!=="number"||value!==Math.floor(value)){throw new Error("Invalid tile value: Expected a whole number.")}this.#map[~~y][~~x]=~~value}get map(){return this.#map}get lights(){return this.#lights}get images(){return this.#images}set map(newMap){if(!Array.isArray(newMap)||!Array.isArray(newMap[0])||!newMap.every(row=>row.every(Number.isInteger))){throw new Error("Invalid map: Expected a 2D array of integers.")}this.#map=newMap}set images(newImages){if(!Array.isArray(newImages)||!newImages.every(image=>image instanceof Image)){throw new Error("Invalid images: Expected an array of Image objects.")}this.#images=newImages}set lights(newLights){if(!Array.isArray(newLights)||!newLights.every(light=>light instanceof Light)){throw new Error("Invalid lights: Expected an array of Light instances.")}this.#lights=newLights}}class Vector{constructor(x,y){if(typeof x!=="number"||typeof y!=="number"){throw new Error("Vector constructor requires two numbers.")}this.x=x;this.y=y}set(x,y){if(typeof x!=="number"||typeof y!=="number"){throw new Error("Vector.set requires two numbers.")}this.x=x;this.y=y}add(v){if(v instanceof Vector){this.x+=v.x;this.y+=v.y}else if(typeof v==="number"){this.x+=v;this.y+=v}else{throw new Error("Vector.add requires a Vector or a number.")}return this.copy()}sub(v){if(v instanceof Vector){this.x-=v.x;this.y-=v.y}else if(typeof v==="number"){this.x-=v;this.y-=v}else{throw new Error("Vector.sub requires a Vector or a number.")}return this.copy()}mult(v){if(v instanceof Vector){this.x*=v.x;this.y*=v.y}else if(typeof v==="number"){this.x*=v;this.y*=v}else{throw new Error("Vector.mult requires a Vector or a number.")}return this.copy()}div(v){if(v instanceof Vector){if(v.x===0||v.y===0){throw new Error("Cannot divide by a Vector with a zero component.")}this.x/=v.x;this.y/=v.y}else if(typeof v==="number"){if(v===0){throw new Error("Cannot divide by zero.")}this.x/=v;this.y/=v}else{throw new Error("Vector.div requires a Vector or a number.")}return this.copy()}normalize(){const len=Math.sqrt(this.x*this.x+this.y*this.y);if(len===0){console.warn("Cannot normalize a zero Vector.")}this.x/=len;this.y/=len;return this.copy()}rotate90(){const temp=this.x;this.x=-this.y;this.y=temp;return this}mag(){return Math.sqrt(this.x*this.x+this.y*this.y)}distance(v){if(!(v instanceof Vector)){throw new Error("Vector.distance requires a Vector.")}const dx=v.x-this.x;const dy=v.y-this.y;return Math.sqrt(dx*dx+dy*dy)}angle(v){if(!(v instanceof Vector)){throw new Error("Vector.angle requires a Vector.")}return Math.atan2(v.y-this.y,v.x-this.x)}dot(v){if(!(v instanceof Vector)){throw new Error("Vector.dot requires a Vector.")}return this.x*v.x+this.y*v.y}cross(v){if(!(v instanceof Vector)){throw new Error("Vector.cross requires a Vector.")}return this.x*v.y-this.y*v.x}lerp(target,alpha){if(!(target instanceof Vector)||!(typeof alpha==="number")||alpha<0||alpha>1){throw new Error("Vector.lerp requires a Vector and a number from 0 to 1!")}this.x+=(target.x-this.x)*alpha;this.y+=(target.y-this.y)*alpha;return this.copy()}reflect(normal){if(!(normal instanceof Vector)){throw new Error("Vector.reflect requires a Vector as a normal.")}let dotProduct=this.dot(normal);return this.copy().sub(normal.copy().mult(2*dotProduct))}copy(){return new Vector(this.x,this.y)}static add(v1,v2){if(!(v1 instanceof Vector)||!(v2 instanceof Vector)){throw new Error("Vector.add requires two Vectors.")}return new Vector(v1.x+v2.x,v1.y+v2.y)}static sub(v1,v2){if(!(v1 instanceof Vector)||!(v2 instanceof Vector)){throw new Error("Vector.sub requires two Vectors.")}return new Vector(v1.x-v2.x,v1.y-v2.y)}static mult(v,n){if(!(v instanceof Vector)||typeof n!=="number"){throw new Error("Vector.mult requires a Vector and a number.")}return new Vector(v.x*n,v.y*n)}static div(v,n){if(!(v instanceof Vector)||typeof n!=="number"){throw new Error("Vector.div requires a Vector and a number.")}if(n===0){throw new Error("Cannot divide by zero.")}return new Vector(v.x/n,v.y/n)}static distance(v1,v2){if(!(v1 instanceof Vector)&&!(v2 instanceof Vector)){throw new Error("Vector.distance requires two Vectors.")}const dx=v1.x-v2.x;const dy=v1.y-v2.y;return Math.sqrt(dx*dx+dy*dy)}static normalize(v){if(!(v instanceof Vector)){throw new Error("Vector.normalize requires a Vector.")}const len=v.mag();if(len===0){throw new Error("Cannot normalize a zero Vector.")}return new Vector(v.x/len,v.y/len)}static dot(v1,v2){if(!(v1 instanceof Vector)||!(v2 instanceof Vector)){throw new Error("Vector.dot requires two Vectors.")}return v1.x*v2.x+v1.y*v2.y}static cross(v1,v2){if(!(v1 instanceof Vector)&&!(v2 instanceof Vector)){throw new Error("Vector.cross requires two Vectors.")}return v1.x*v2.y-v1.y*v2.x}static lerp(from,target,alpha){if(!(target instanceof Vector)||!(from instanceof Vector)||!(typeof alpha==="number")||alpha<0||alpha>1){throw new Error("Vector.lerp requires two Vectors and a number from 0 to 1!")}from.x+=(target.x-from.x)*alpha;from.y+=(target.y-from.y)*alpha;return from.copy()}}